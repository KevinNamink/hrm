<?php
// This file is part of the Huygens Remote Manager
// Copyright and license notice: see license.txt

require_once ("Parameter.inc.php");
require_once ("Database.inc.php");
require_once ("User.inc.php");
require_once ("hrm_config.inc.php");

/*!
  \class    Setting
  \brief    (Abstract) base class for all specific Setting classes
 */
abstract class Setting {

    /*!
      \var		$parameter
      \brief	Array of Parameter object
    */
    protected $parameter;

    /*!
      \var	$message
      \brief	Message for last invalid Parameter check
    */
    protected $message;

    /*!
      \var	$owner
      \brief	The User or Owner of the Setting
    */
    protected $owner;

    /*!
      \var	$name
      \brief	The name of the Setting
    */
    protected $name;

    /*!
      \var	$isDefault
      \brief	If true, the Setting is the default
    */
    protected $isDefault;

    /*!
      \var		$numberOfChannels
      \brief	Number of channels associated with the Setting
    */
    protected $numberOfChannels;

    /*!
      \brief	Protected constructor: creates an empty Setting
    */
    protected function __construct() {
        $this->parameter = array ();
        $this->isDefault = False;
    }

    /*!
     * Deep copy method.
     *
     * Call:
     *
     *    $settingClone = clone $setting
     *
     * to get a deep copy of the original object.
     */
    public function __clone() {
        foreach($this as $key => $val) {
            if (is_object($val) || (is_array($val))) {
                $this->{$key} = unserialize(serialize($val));
            }
        }
    }

    /*!
      \brief	Returns the Parameter of given name
      \param	$name	Name of the Parameter to return
      \return	a Parameter object or NULL if the Parameter does not exist
    */
    public function parameter($name) {
        if (isset($this->parameter[$name])) {
            return $this->parameter[$name];
        } else {
            return NULL;
        }
    }

    /*!
      \brief	Sets a Parameter. The Parameter is stored in the Setting under
              its name.
      \param	$parameter	A Parameter.
    */
    public function set($parameter) {
        $this->parameter[$parameter->name()] = $parameter;
    }

    /*!
      \brief  Returns the (error) message generated by last Parameter check
      \return	(error) message
    */
    public function message() {
        return $this->message;
    }

    /*!
      \brief	Return all Parameter names
      \return	array of parameter names
    */
    public function parameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            $names[] = $parameter->name();
        }
        return $names;
    }

    /*!
      \brief	Returns the User owner of the Setting
      \return	Owner of the Setting
    */
    public function owner() {
        return $this->owner;
    }

    /*!
      \brief  Sets the User owner of the Setting
      \param  $owner	The owner of the Setting
    */
    public function setOwner(User $owner) {
        $this->owner = $owner;
    }

    /*!
      \brief	Returns the name of the Setting
      \return	name of the Setting
    */
    public function name() {
        return $this->name;
    }

    /*!
      \brief  Sets the name of the Setting
      \param  $name	Name of the Setting
    */
    public function setName($name) {
        $this->name = $name;
    }

    /*!
      \brief  Checks whether the Setting is the user's default setting
      \return	true if the Setting is the default Setting, false otherwise
    */
    public function isDefault() {
        return $this->isDefault;
    }

    /*!
      \brief  Sets current Setting as the default Setting for the user
    */
    public function beDefault() {
        $this->isDefault = True;
    }

    /*!
      \brief  Resets current Setting as no longer the default Setting for the user
    */
    public function resetDefault() {
        $this->isDefault = False;
    }

    /*!
      \brief  Copies the Parameter values from another Setting
      \param  $setting  The other Setting object from which the values are copied
    */
    public function copyParameterFrom($setting) {
        foreach ($setting->parameterNames() as $name) {
            $parameter = $this->parameter[$name];
            $otherParameter = $setting->parameter($name);
            $newValue = $otherParameter->internalValue();    
            $parameter->setValue($newValue);
            $this->parameter[$name] = $parameter;
        }
    }

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag. This is an abstract function and must
      be reimplemented.
    */
    abstract static function table();

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()

      This is an abstract function and must be reimplemented.
      \see table()
    */
    abstract static function parameterTable();

    /*!
      \brief  Loads the Parameter values into current Setting
      \return	the loaded Setting
    */
    public function load() {
        $db = new DatabaseConnection();
        $result = $db->loadParameterSettings($this);
        if (!$result) {
            $this->message = "Could not load settings!";
        }
        return $result;
    }

    /*!
      \brief  Saves all Parameter values from current Setting to the database
      \return	true if saving was successful, false otherwise
    */
    public function save() {
        $db = new DatabaseConnection();
        $result = $db->saveParameterSettings($this);
        if (!$result) {
            $this->message = "Could not save settings!";
        }
        return $result;
    }

    /*!
      \brief  Shares the selected setting with the given user.
      \param String $username Name of the user to share with
      \return	true if sharing was successful, false otherwise
    */
    public function shareWith($username) {
        $db = new DatabaseConnection();
        $settings = $db->loadParameterSettings($this);
        $result = $db->saveSharedParameterSettings($settings, $username);
        if (!$result) {
            $this->message = "Sharing template failed!" ;
        } else {
            $this->message = "Template successfully shared!";
        }
        return $result;
    }

    /*!
      \brief	Sets the number of channels for the Setting

      All variable channels Parameter objects in the Setting will updated.

      \param	$channels	Number of channels (between 1 and 6)
    */
    public function setNumberOfChannels($channels) {
        $this->numberOfChannels = $channels;
        foreach ($this->parameter as $parameter) {
            if ($parameter->isVariableChannel()) {
                $parameter->setNumberOfChannels($this->numberOfChannels);
                $this->set($parameter);
            }
        }
    }

    /*!
  \brief	parses an array retuned by hucore after it has read a file
    This is an abstract function and must
  be reimplemented.
*/
 //   abstract public function ($hucorearray);

} // End of Setting class

/*
 ============================================================================
 */

/*!
  \class  ParameterSetting
  \brief	A ParameterSetting is a complete set of microscope, image and
            capture parameters
*/
class ParameterSetting extends Setting {

    /*!
      \brief	Constructor: constructs and initializes a ParameterSetting
    */
    public function __construct() {
        parent::__construct();
        $parameterClasses = array(
            'IsMultiChannel',
            'ImageFileFormat',
            'NumberOfChannels',
            'MicroscopeType',
            'NumericalAperture',
            'ObjectiveMagnification',
            'ObjectiveType',
            'SampleMedium',
            'Binning',
            'ExcitationWavelength',
            'EmissionWavelength',
            'CMount',
            'TubeFactor',
            'CCDCaptorSize',
            'CCDCaptorSizeX',
            'ZStepSize',
            'TimeInterval',
            'PinholeSize',
            'PinholeSpacing',
            'PointSpreadFunction',
            'PSF',
            'CoverslipRelativePosition',
            'AberrationCorrectionNecessary',
            'PerformAberrationCorrection',
            'AberrationCorrectionMode',
            'AdvancedCorrectionOptions',
            'PSFGenerationDepth',
            'StedDepletionMode',
            'StedSaturationFactor',
            'StedWavelength',
            'StedImmunity',
            'Sted3D',
            'SpimExcMode',
            'SpimGaussWidth',
            'SpimFocusOffset',
            'SpimCenterOffset',
            'SpimNA',
            'SpimFill',
            'SpimDir'
        );
        foreach ($parameterClasses as $class) {
            $param = new $class;
            $name = $param->name();
            $this->parameter[$name] = $param;
        }
    }

    /*!
      \brief	Returns the name of the database table in which the list of
      Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag.
    */
    public static function table() {
        return "parameter_setting";
    }

    /*!
      \brief	Returns the name of the database table in which the list of
      shared Setting names are stored.
    */
    public static function sharedTable() {
        return "shared_parameter_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()
      \see table()
    */
    public static function parameterTable() {
        return "parameter";
    }

    /*!
      \brief	Returns the name of the database table to use for sharing
                settings.
      \see table()
    */
    public static function sharedParameterTable() {
        return "shared_parameter";
    }


    /*!
     \brief    A general check on  the status of the image parameter setting
               and its compatibility with the selected image format.
     \return   Boolean: true if the setting is OK.
    */
    public function checkParameterSetting( ) {

        $ok = True;

        /* Initialization: among others, create an array where to
           accumulate the microscopic parameters.*/
        $postedParams = array();

        $db = new DatabaseConnection();
        $imageFormat = $this->parameter("ImageFileFormat")->value();

        /* Loop over the values of this setting's parameters. */
        foreach ($this->parameter as $objName => $objInstance) {

            switch ( $objName ) {
                case "StedDepletionMode" :
                case "StedWavelength" :
                case "StedSaturationFactor" :
                case "StedImmunity" :
                case "Sted3D" :
                case "ExcitationWavelength" :
                case "EmissionWavelength" :
                case "PinholeSize" :
                    $chanValues = $objInstance->value();

                    foreach ( $chanValues as $chan => $value) {
                        if (isset($value)) {
                            $postedParams["$objName$chan"] = $value;
                        }
                    }
                default:
                    $postedParams[$objName] = $objInstance->value();
            }

                /* Set the confidence level of this parameter according
                 to the file format chosen in the image selection page. */
            $cLevel = $db->getParameterConfidenceLevel( $imageFormat, $objName );
            $objInstance->setConfidenceLevel( $cLevel );
        }

            /* Check if the status of the parameter setting is compatible
             with the selected file format. */

        if ( !$this->checkPostedImageParameters($postedParams) ) {
            $ok = False;
        }

        if ($ok) {
            if (  !$this->checkPostedMicroscopyParameters($postedParams) ) {
                $ok = False;
            }
        }

        if ($ok) {
            if ( !$this->checkPostedCapturingParameters($postedParams) ) {
                $ok = False;
            }
        }

        if ($ok) {
            if ( !$this->checkPostedStedParameters($postedParams) )  {
                $ok = False;
            }
        }

        if ( !$ok ) {
            $this->message  = "The selected parameter set contains empty values ";
            $this->message .= "which the $imageFormat format misses in its ";
            $this->message .= "metadata. Please proceed to add them or select a ";
            $this->message .= "different parameter set.";
        }

        return $ok;
    }


    /*!
      \brief	Checks that the posted Image Parameters are all defined
              and valid

      These Parameters must all be defined.

      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedImageParameters($postedParameters) {

        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $this->message = '';
        $noErrorsFound = True;

        // The PSF type must be defined
        if (!isset($postedParameters["PointSpreadFunction"]) ||
                $postedParameters["PointSpreadFunction"] == "") {
            $this->message = "Please indicate whether you " .
                    "would like to calculate a theoretical PSF " .
                    "or use an existing measured one!";
            return False;
        } else {
            $parameter = $this->parameter("PointSpreadFunction");
            $parameter->setValue($postedParameters["PointSpreadFunction"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                return False;
            }
        }

        // The number of channels must be defined for all file formats
        if (!isset($postedParameters["NumberOfChannels"]) ||
                $postedParameters["NumberOfChannels"] == "") {
            $this->message = "Please set the number of channels!";
            return False;
        }
        $parameter = $this->parameter("NumberOfChannels");
        $parameter->setValue($postedParameters["NumberOfChannels"]);
        $this->set($parameter);
        if (!$parameter->check()) {
            $this->message = $parameter->message();
            return False;
        }

        // All checked correctly, we can return success
        $this->message = "";
        return True;
    }

    /*!
      \brief	Checks that the posted Microscopy Parameters are all
              defined and valid

      These Parameter might have different confidence levels

      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedMicroscopyParameters($postedParameters) {
        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();

        $this->message = '';
        $noErrorsFound = True;

        // Get the names of the relevant parameters
        $names = $this->microscopeParameterNames();

        // Small correction to the multi-channel names
        $names[array_search('ExcitationWavelength', $names)] =
            'ExcitationWavelength0';
        $names[array_search('EmissionWavelength', $names)] =
            'EmissionWavelength0';

        // We handle multi-value parameters differently than single-valued ones

        // Excitation wavelengths
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["ExcitationWavelength$i"])) {
                $value[$i] = $postedParameters["ExcitationWavelength$i"];
                unset($postedParameters["ExcitationWavelength$i"]);
            }
        }
        $name = 'ExcitationWavelength';
        unset($names[array_search("ExcitationWavelength0", $names)]);
        $valueSet = count(array_filter($value)) > 0;

        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            // Check
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the excitation wavelength!";
                $noErrorsFound = False;
            }

        }

        // Emission wavelengths
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["EmissionWavelength$i"])) {
                $value[$i] = $postedParameters["EmissionWavelength$i"];
                unset($postedParameters["EmissionWavelength$i"]);
            }
        }
        $name = 'EmissionWavelength';
        unset($names[array_search("EmissionWavelength0", $names)]);
        $valueSet = count(array_filter($value)) > 0;

        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            // Check
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the emission wavelength!";
                $noErrorsFound = False;
            }

        }

        // Check that the Parameters are set and contain valid values
        foreach ($names as $name) {

            // State of the Parameter and the submitted value(s)
            $valueSet = isset($postedParameters[$name]) &&
                    $postedParameters[$name] != '';

            // If the value is set, we check it no matter if it must be
            // provided or not
            if ($valueSet) {

                if ($name == "SampleMedium"
                    && $postedParameters[$name] == "custom") {
                    if (isset($postedParameters['SampleMediumCustomValue'])) {
                        $value = $postedParameters['SampleMediumCustomValue'];
                    }
                } elseif($name == "ObjectiveType"
                         && $postedParameters[$name] == "custom") {
                    $value = $postedParameters['ObjectiveTypeCustomValue'];
                } else {
                    $value = $postedParameters[$name];
                }

                // If the value is set we must check it (independent of the
                // $mustProvide flag)
                $parameter = $this->parameter($name);
                $parameter->setValue($value);

                $this->set($parameter);
                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }
            } else {

                // In this case it is important to know whether the Parameter
                // must have a value or not
                $parameter = $this->parameter($name);
                $mustProvide = $parameter->mustProvide();

                // Reset the Parameter
                $parameter->reset();
                $this->set($parameter);

                // If the Parameter value must be provided, we return an error
                if ($mustProvide) {

                    switch ($name) {
                        case "MicroscopeType" :
                            $this->message =
                                "Please set the microscope type!";
                            break;
                        case "NumericalAperture" :
                            $this->message =
                                "Please set the numerical aperture!";
                            break;
                        case "ObjectiveType" :
                            $this->message =
                                "Please set the objective type!";
                            break;
                        case "SampleMedium" :
                            $this->message =
                                "Please set the refractive index " .
                                    "of the sample medium!";
                            break;
                        case "ExcitationWavelength" :
                            $this->message =
                                "Please set the excitation wavelength!";
                            break;
                        case "EmissionWavelength" :
                            $this->message =
                                "Please set the emission wavelength!";
                            break;
                    }
                    $noErrorsFound = False;
                }
            }
        }

        return $noErrorsFound;
    }

    /*!
      \brief	Checks that the posted SPIM Parameters are all defined
              and valid
      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedSpimParameters($postedParameters) {
        $this->message = '';

        if (count($postedParameters) == 0) {
            return False;
        }

        if (!$this->isSpim()) {
            return True;
        }

        $noErrorsFound = True;

        // Excitation Mode
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimExcMode$i"])) {
                $value[$i] = $postedParameters["SpimExcMode$i"];
                unset($postedParameters["SpimExcMode$i"]);
            }
        }
        $name = 'SpimExcMode';
        $valueSet = count(array_filter($value)) > 0;

        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            // Keep the 'excModes' so that it can be checked below if any SPIM
            // parameters need to be forced, e.g when 'excMode' is 'High NA'.
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            } else {
                $excModes = $parameter->value();
            }
        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the SPIM excitation mode!";
                $noErrorsFound = False;
            }
        }
        

        // Gaussian Width
        $value = array(null, null, null, null, null);

        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimGaussWidth$i"])) {
                $value[$i] = $postedParameters["SpimGaussWidth$i"];
                unset($postedParameters["SpimGaussWidth$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is 'High NA'.
                if (empty($value[$i])
                    && isset($excModes[$i])
                    && $excModes[$i] == "High NA") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'SpimGaussWidth';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim Gaussian Width!";
                $noErrorsFound = False;
            }
        }


        // Spim Sheet Focus Offset
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimFocusOffset$i"])) {
                $value[$i] = $postedParameters["SpimFocusOffset$i"];
                unset($postedParameters["SpimFocusOffset$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is 'High NA'.
                if (empty($value[$i])
                    && isset($excModes[$i])
                    && $excModes[$i] == "High NA") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'SpimFocusOffset';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim Focus Offset!";
                $noErrorsFound = False;
            }
        }


        // Spim Sheet Center Offset
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimCenterOffset$i"])) {
                $value[$i] = $postedParameters["SpimCenterOffset$i"];
                unset($postedParameters["SpimCenterOffset$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is 'High NA'.
                if (empty($value[$i])
                    && isset($excModes[$i])
                    && $excModes[$i] == "High NA") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'SpimCenterOffset';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim Center Offset!";
                $noErrorsFound = False;
            }
        }
        

        // Spim NA
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimNA$i"])) {
                $value[$i] = $postedParameters["SpimNA$i"];
                unset($postedParameters["SpimNA$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is not 'High NA'.
                if (empty($value[$i])
                    && isset($excModes[$i])
                    && $excModes[$i] != "High NA") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'SpimNA';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim NA!";
                $noErrorsFound = False;
            }
        }


        // Spim Fill Factor
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimFill$i"])) {
                $value[$i] = $postedParameters["SpimFill$i"];
                unset($postedParameters["SpimFill$i"]);
                
                // Fallback to '0' if no value was provided and
                // the channel is not 'High NA'.
                if (empty($value[$i])
                    && isset($excModes[$i])
                    && $excModes[$i] != "High NA") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'SpimFill';
        
        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {
            
            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);
            
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
            
        } else {
            
            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();
            
            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);
            
            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim Fill Factor!";
                $noErrorsFound = False;
            }
        }


        // Spim Direction
        $value = array(null, null, null, null, null);
        for ($i = 0; $i < 5; $i++) {
            if (isset($postedParameters["SpimDir$i"])) {
                $value[$i] = $postedParameters["SpimDir$i"];
                unset($postedParameters["SpimDir$i"]);
            }
        }
        $name = 'SpimDir';
        
        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {
            
            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);
            
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
            
        } else {
            
            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();
            
            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);
            
            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Spim Direction!";
                $noErrorsFound = False;
            }
        }       

        return $noErrorsFound;
    }

    /*!
      \brief	Checks that the posted STED Parameters are all defined
              and valid
      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedStedParameters($postedParameters) {
        if (count($postedParameters) == 0) {
            return False;
        }

        if (!$this->isSted() && !$this->isSted3D()) {
            return True;
        }
        
        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();
        
        $this->message = '';
        $noErrorsFound = True;

        // Depletion Mode
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["StedDepletionMode$i"])) {
                $value[$i] = $postedParameters["StedDepletionMode$i"];
                unset($postedParameters["StedDepletionMode$i"]);
            }
        }
        $name = 'StedDepletionMode';
        $valueSet = count(array_filter($value)) > 0;

        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            // Keep the 'deplModes' so that it can be checked below if any STED
            // parameters need to be forced, e.g when 'deplMode' is 'confocal'.
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            } else {
                $deplModes = $parameter->value();
            }
        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Sted depletion mode!";
                $noErrorsFound = False;
            }
        }


        // Saturation Factor
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["StedSaturationFactor$i"])) {
                $value[$i] = $postedParameters["StedSaturationFactor$i"];
                unset($postedParameters["StedSaturationFactor$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is confocal.
                if (empty($value[$i])
                    && isset($deplModes[$i])
                    && $deplModes[$i] == "off-confocal") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'StedSaturationFactor';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Sted saturation factor!";
                $noErrorsFound = False;
            }
        }


        // Sted Wavelength
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["StedWavelength$i"])) {
                $value[$i] = $postedParameters["StedWavelength$i"];
                unset($postedParameters["StedWavelength$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is confocal.
                if (empty($value[$i])
                    && isset($deplModes[$i])
                    && $deplModes[$i] == "off-confocal") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'StedWavelength';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Sted wavelength!";
                $noErrorsFound = False;
            }
        }


        // Sted Immunity Fraction
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            if (isset($postedParameters["StedImmunity$i"])) {
                $value[$i] = $postedParameters["StedImmunity$i"];
                unset($postedParameters["StedImmunity$i"]);

                // Fallback to '0' if no value was provided and
                // the channel is confocal.
                if (empty($value[$i])
                    && isset($deplModes[$i])
                    && $deplModes[$i] == "off-confocal") {
                    $value[$i] = 0;
                }
            }
        }
        $name = 'StedImmunity';

        // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
        $valueSet = count(array_filter($value, 'strlen')) > 0;
        if ($valueSet) {

            // Set the value
            $parameter = $this->parameter($name);
            $parameter->setValue($value);
            $this->set($parameter);

            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }

        } else {

            // In this case it is important to know whether the Parameter
            // must have a value or not
            $parameter = $this->parameter($name);
            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the Sted immunity fraction!";
                $noErrorsFound = False;
            }
        }


        // Sted 3D
        if ($this->isSted3D()) {
            for ($i = 0; $i < $maxChanCnt; $i++) {
                $value[$i] = null;
                if (isset($postedParameters["Sted3D$i"])) {
                    $value[$i] = $postedParameters["Sted3D$i"];
                    unset($postedParameters["Sted3D$i"]);

                    // Fallback to '0' if no value was provided and
                    // the channel is confocal.
                    if (empty($value[$i])
                        && isset($deplModes[$i])
                        && $deplModes[$i] == "off-confocal") {
                        $value[$i] = 0;
                    }
                }
            }
            $name = 'Sted3D';

            // Do not filter '0'. Thus, use 'strlen' as callback for filtering.
            $valueSet = count(array_filter($value, 'strlen')) > 0;
            if ($valueSet) {

                // Set the value
                $parameter = $this->parameter($name);
                $parameter->setValue($value);
                $this->set($parameter);

                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }

            } else {

                // In this case it is important to know whether the Parameter
                // must have a value or not
                $parameter = $this->parameter($name);
                $mustProvide = $parameter->mustProvide();

                // Reset the Parameter
                $parameter->reset();
                $this->set($parameter);

                // If the Parameter value must be provided, we return an error
                if ($mustProvide) {
                    $this->message = "Please set the Sted 3D percentage!";
                    $noErrorsFound = False;
                }
            }
        }


        return $noErrorsFound;
    }   

    /*!
      \brief	Checks that the posted Capturing Parameters are all defined
              and valid
      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedCapturingParameters($postedParameters) {
        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();

        $this->message = '';
        $noErrorsFound = True;

        // Here we test the Parameters explicitly
        // CCDCaptorSizeX
        $valueSet = isset($postedParameters["CCDCaptorSizeX"]) &&
                $postedParameters["CCDCaptorSizeX"] != '';

        $parameter = $this->parameter("CCDCaptorSizeX");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["CCDCaptorSizeX"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the pixel size!";
                $noErrorsFound = False;
            }
        }

        // ZStepSize
        $valueSet = isset($postedParameters["ZStepSize"]) &&
                $postedParameters["ZStepSize"] != '';

        $parameter = $this->parameter("ZStepSize");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["ZStepSize"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the z-step!";
                $noErrorsFound = False;
            }
        }


        // TimeInterval
        $valueSet = isset($postedParameters["TimeInterval"]) &&
                $postedParameters["TimeInterval"] != '';

        $parameter = $this->parameter("TimeInterval");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["TimeInterval"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();
            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the time interval!";
                $noErrorsFound = False;
            }
        }

        // PinholeSize must be defined for all confocal microscopes
        if ($this->hasPinhole()) {

            // Pinhole sizes
            for ($i = 0; $i < $maxChanCnt; $i++) {
                $value[$i] = null;
                if (isset($postedParameters["PinholeSize$i"])) {
                    $value[$i] = $postedParameters["PinholeSize$i"];
                    unset($postedParameters["PinholeSize$i"]);
                }
            }
            $name = 'PinholeSize';
            $valueSet = count(array_filter($value)) > 0;
            if ($valueSet) {

                // Set the value
                $parameter = $this->parameter($name);
                $parameter->setValue($value);
                $this->set($parameter);

                // Check
                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }

            } else {

                // In this case it is important to know whether the Parameter
                // must have a value or not
                $parameter = $this->parameter($name);
                $mustProvide = $parameter->mustProvide();

                // Reset the Parameter
                $parameter->reset();
                $this->set($parameter);

                // If the Parameter value must be provided, we return an error
                if ($mustProvide) {
                    $this->message = "Please set the pinhole size!";
                    $noErrorsFound = False;
                }

            }
        }

        // PinholeSpacing must be defined for spinning disk confocals
        if ($this->isNipkowDisk()) {

            $valueSet = isset($postedParameters["PinholeSpacing"]) &&
                    $postedParameters["PinholeSpacing"] != '';

            $parameter = $this->parameter("PinholeSpacing");

            if ($valueSet) {

                // Set the Parameter and check the value
                $parameter->setValue($postedParameters["PinholeSpacing"]);
                $this->set($parameter);
                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }
            } else {

                $mustProvide = $parameter->mustProvide();

                // Reset the Parameter
                $parameter->reset();
                $this->set($parameter);

                // If the Parameter value must be provided, we return an error
                if ($mustProvide) {
                    $this->message = "Please set the pinhole spacing!";
                    $noErrorsFound = False;
                }
            }
        }

        if ($this->isSted() || $this->isSted3D()) {
            $noErrorsFound = True;
        }

        return $noErrorsFound;
    }


    /*!
      \brief	Checks that the posted Aberration Correction Parameters are all
              defined and valid
      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedAberrationCorrectionParameters($postedParameters) {

        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $this->message = '';
        $noErrorsFound = True;

        // PerformAberrationCorrection
        $valueSet = isset($postedParameters["PerformAberrationCorrection"]) &&
                $postedParameters["PerformAberrationCorrection"] != '';

        $parameter = $this->parameter("PerformAberrationCorrection");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["PerformAberrationCorrection"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message =
                    "Please choose whether to perform the correction!";
                $noErrorsFound = False;
            }
        }

        // If the aberration correction is inactive, there is no point in
        // checking the other parameters.
        if ($this->parameter("PerformAberrationCorrection")->value() == 0) {
            return $noErrorsFound;
        }

        // CoverslipRelativePosition
        $valueSet = isset($postedParameters["CoverslipRelativePosition"]) &&
                $postedParameters["CoverslipRelativePosition"] != '';

        $parameter = $this->parameter("CoverslipRelativePosition");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["CoverslipRelativePosition"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message =
                    "Please choose the relative coverslip position!";
                $noErrorsFound = False;
            }
        }

        // AberrationCorrectionMode
        $valueSet = isset($postedParameters["AberrationCorrectionMode"]) &&
                $postedParameters["AberrationCorrectionMode"] != '';

        $parameter = $this->parameter("AberrationCorrectionMode");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["AberrationCorrectionMode"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message = "Please set the aberration correction mode!";
                $noErrorsFound = False;
            }
        }

        // AdvancedCorrectionOptions
        $valueSet = isset($postedParameters["AdvancedCorrectionOptions"]) &&
                $postedParameters["AdvancedCorrectionOptions"] != '';

        $parameter = $this->parameter("AdvancedCorrectionOptions");

        if ($valueSet) {

            // Set the Parameter and check the value
            $parameter->setValue($postedParameters["AdvancedCorrectionOptions"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        } else {

            $mustProvide = $parameter->mustProvide();

            // Reset the Parameter
            $parameter->reset();
            $this->set($parameter);

            // If the Parameter value must be provided, we return an error
            if ($mustProvide) {
                $this->message =
                    "Please indicate the options for the advanced correction!";
                $noErrorsFound = False;
            }
        }

        // The following Parameters may be defined depending on the values of
        // the previous one, but we will check them only if no errors have been
        // found so far
        if ($noErrorsFound == False) {
            return $noErrorsFound;
        }

        $parameter = $this->parameter("PerformAberrationCorrection");
        $perform = $parameter->value();
        $parameter = $this->parameter("AberrationCorrectionMode");
        $mode = $parameter->value();

        if ($perform == 1 && $mode == "advanced") {

            // PSFGenerationDepth
            $valueSet = isset($postedParameters["PSFGenerationDepth"]) &&
                    $postedParameters["PSFGenerationDepth"] != '';

            $parameter = $this->parameter("PSFGenerationDepth");

            if ($valueSet) {

                // Set the Parameter and check the value
                $parameter->setValue($postedParameters["PSFGenerationDepth"]);
                $this->set($parameter);
                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }
            } else {

                $mustProvide = $parameter->mustProvide();

                // Reset the Parameter
                $parameter->reset();
                $this->set($parameter);

                // If the Parameter value must be provided, we return an error
                if ($mustProvide) {
                    $this->message =
                        "Please indicate the depth for PSF generation!";
                    $noErrorsFound = False;
                }
            }
        }

        return $noErrorsFound;
    }

    
    /*!
      \brief	Checks that the posted Calculate Pixel Size Parameters are all defined
              and valid
      \param	$postedParameters	The $_POST array
      \return	true if all Paraneters are defined and valid, false otherwise
    */
    public function checkPostedCalculatePixelSizeParameters($postedParameters) {

        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $this->message = '';
        $noErrorsFound = True;

        $names = $this->pixelSizeCalculationParameterNames();

        // Check that the Parameters are set and contain valid values
        foreach ($names as $name) {
            if (!isset($postedParameters[$name]) ||
                    $postedParameters[$name] == '') {
                // The Parameter is not set or empty, return an informative
                // error message
                switch ($name) {
                    case "CCDCaptorSize" :
                        $this->message = "Please set the CCD pixel size!";
                        break;
                    case "Binning" :
                        $this->message = "Please set the binning!";
                        break;
                    case "NumberOfChannels" :
                        $this->message = "Please set CMount!";
                        break;
                    case "TubeFactor" :
                        $this->message = "Please set the tube factore!";
                        break;
                    case "ObjectiveMagnification" :
                        $this->message =
                            "Please set the objective magnification!";
                        break;
                }
                $noErrorsFound = False;
            } else {
                // The Parameter is set, now check the value
                $parameter = $this->parameter($name);
                $parameter->setValue($postedParameters[$name]);
                $this->set($parameter);
                if (!$parameter->check()) {
                    $this->message = $parameter->message();
                    $noErrorsFound = False;
                }
            }
        }

        return $noErrorsFound;
    }

    /*!
      \brief	Returns the Parameter values needed for the aberration correction
      \return array with all Parameter values for the aberration correction.
              The keys are the Parameter names
     */
    public function getAberractionCorrectionParameters() {
        $parameters = array(
            'AberrationCorrectionNecessary' =>
                $this->parameter('AberrationCorrectionNecessary')->value(),
            'PerformAberrationCorrection' =>
                $this->parameter('PerformAberrationCorrection')->value(),
            'CoverslipRelativePosition' =>
                $this->parameter('CoverslipRelativePosition')->value(),
            'AberrationCorrectionMode' =>
                $this->parameter('AberrationCorrectionMode')->value(),
            'AdvancedCorrectionOptions' =>
                $this->parameter('AdvancedCorrectionOptions')->value(),
            'PSFGenerationDepth' =>
                $this->parameter('PSFGenerationDepth')->value());
        return $parameters;
    }

    /*!
      \brief	Returns all Image Parameter names
      \return array of Image Parameter names
    */
    public function imageParameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            if ($parameter->isForImage()) {
                $names[] = $parameter->name();
            }
        }

        return $names;
    }

    /*!
      \brief	Returns all Microscope Parameter names
      \return array of Microscope Parameter names
    */
    public function microscopeParameterNames() {
        $names = array();

        foreach ($this->parameter as $parameter) {
            if ($parameter->isForMicroscope()) {
                $names[] = $parameter->name();
            }
        }

        return $names;
    }

    /*!
      \brief	Returns all Sted Parameter names
      \return array of Sted Parameter names
    */
    public function stedParameterNames() {
        $names = array();

        foreach ($this->parameter as $parameter) {
            if ($parameter->isForSted()) {
                $names[] = $parameter->name();
            }
        }

        return $names;
    }

    /*!
      \brief	Returns all Spim Parameter names
      \return array of Spim Parameter names
    */
    public function spimParameterNames() {
        $names = array();

        foreach ($this->parameter as $parameter) {
            if ($parameter->isForSpim()) {
                $names[] = $parameter->name();
            }
        }

        return $names;
    }

    /*!
      \brief	Returns all Capture Parameter names
      \return array of Capture Parameter names
     */
    public function capturingParameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            if ($parameter->isForCapture()) {
                $names[] = $parameter->name();
            }
        }
        return $names;
    }

    /*!
      \brief	Returns all Correction Parameter names
      \return array of Correction Parameter names
    */
    public function correctionParameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            if ($parameter->isForCorrection()) {
                $names[] = $parameter->name();
            }
        }
        return $names;
    }

    /*!
      \brief	Returns all Correction Parameter names
      \return array of Correction Parameter names
    */
    public function pixelSizeCalculationParameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            if ($parameter->isForPixelSizeCalculation()) {
                $names[] = $parameter->name();
            }
        }
        return $names;
    }

    /*!
      \brief  Displays the setting as a text containing Parameter names and
              their values
    */
    public function displayString($numberOfChannels = 0, $micrType = NULL) {
        $result = '';


        // These parameters are important to properly display all the others
        $numberOfChannels = $this->parameter("NumberOfChannels")->value();
        $PSFmode = $this->parameter("PointSpreadFunction")->value();
        $performAberrationCorrection =
            $this->parameter("PerformAberrationCorrection")->value();
        $aberrationCorrectionMode =
            $this->parameter("AberrationCorrectionMode")->value();
        $advancedCorrectionOptions =
            $this->parameter("AdvancedCorrectionOptions")->value();

        // Not everything needs to be displayed, either because the Parameter
        // might be only internally used, or because it does not make sense for
        // the current Setting (e.g. it does not make sense to display the
        // pinhole size if the microscope type is 'widefield'.
        foreach ($this->parameter as $parameter) {
            if (!$this->hasPinhole() && $parameter->name() == 'PinholeSize')
                continue;
            if ($parameter->name() == 'ImageFileFormat')
                continue;
            if ($parameter->name() == 'IsMultiChannel')
                continue;
            if (!$this->isNipkowDisk() &&
                    $parameter->name() == 'PinholeSpacing')
                continue;
            if ($parameter->name() == 'CMount') // This is obsolete
                continue;
            if ($parameter->name() == 'TubeFactor') // This is obsolete
                continue;
            if ($parameter->name() == 'ObjectiveMagnification') // This is obsolete
                continue;
            if ($parameter->name() == 'Binning') // This is obsolete
                continue;
            if ($parameter->name() == "AberrationCorrectionNecessary" &&
                    $PSFmode == 'measured')
                continue;
            if ($parameter->name() == 'CoverslipRelativePosition' &&
                    $PSFmode == 'measured')
                continue;
            if ($parameter->name() == 'PSF' && $PSFmode == 'theoretical')
                continue;
            if ($parameter->name() == 'CoverslipRelativePosition' &&
                    $performAberrationCorrection == 0)
                continue;
            if ($parameter->name() == 'AberrationCorrectionMode' &&
                    $performAberrationCorrection == 0)
                continue;
            if ($parameter->name() == 'AdvancedCorrectionOptions' &&
                    !( $performAberrationCorrection == 1 &&
                    $aberrationCorrectionMode == 'advanced' ))
                continue;
            if ($parameter->name() == 'PSFGenerationDepth' &&
                    !( $performAberrationCorrection == 1 &&
                    $aberrationCorrectionMode == 'advanced' &&
                    $advancedCorrectionOptions == 'user' ))
                continue;
            if ($parameter->name() == 'StedDepletionMode'
                && (!$this->isSted() && !$this->isSted3D()))
                continue;
            if ($parameter->name() == 'StedSaturationFactor'
                && (!$this->isSted() && !$this->isSted3D()))
                continue;
            if ($parameter->name() == 'StedWavelength'
                && (!$this->isSted() && !$this->isSted3D()))
                continue;
            if ($parameter->name() == 'StedImmunity'
                && (!$this->isSted() && !$this->isSted3D()))
                continue;
            if ($parameter->name() == 'Sted3D' && !$this->isSted3D())
                continue;
            if ($parameter->name() == 'PSF' && $PSFmode == 'measured') {

                // If this is a shared template, process the PSF file paths
                // to return the final path as it will be when the shared
                // template is accepted.
                $buffer = "psf_sharing/buffer/";
                $psfFiles = $parameter->value();
                for ($i = 0; $i < count($psfFiles); $i++) {

                    // Get current PSF file path
                    $f = $psfFiles[$i];

                    // Process it
                    $pos = strpos($f, $buffer);
                    if ($pos === 0) {

                        // Remove all temporary path prefix
                        $tmp = substr($f, strlen($buffer));
                        $pos = strpos($tmp, "/");
                        $tmp = substr($tmp, $pos + 1); // Remove owner
                        $pos = strpos($tmp, "/");
                        $tmp = substr($tmp, $pos + 1); // Remove previous owner

                        // Update the parameter
                        $psfFiles[$i] = $tmp;
                    }
                }
                $parameter->setValue($psfFiles);
                $result = $result . $parameter->displayString($numberOfChannels);
                continue;
            }
            $result = $result . $parameter->displayString($numberOfChannels);
        }
        return $result;
    }

    /*!
      \brief	Asks HuCore to calculate the ideal (Nyquist) sampling rate
              for the current conditions.
      \return	an array with the ideal XY and Z sampling, or false if the sampling
              could not be calculated due to missing values
    */
    public function calculateNyquistRate() {
        // Use the most restrictive wavelength to compute the adaption
        $parameter = $this->parameter('EmissionWavelength');
        if ($this->isTwoPhoton()
                || $this->isMultiPointOrSinglePointConfocal()) {
            $parameter = $this->parameter('ExcitationWavelength');
        }
        $value = $parameter->value();
        $mostRestrictiveChannel = 0;
        $mostRestrictiveWavelength = $value[0];
        for ($i = 1; $i < $this->numberOfChannels(); $i++) {
            if ($value[$i] < $mostRestrictiveWavelength) {
                $mostRestrictiveChannel = $i;
                $mostRestrictiveWavelength = $value[$i];
            }
        }
        $parameter = $this->parameter('EmissionWavelength');
        $value = $parameter->value();
        $em = $value[$mostRestrictiveChannel];
        $parameter = $this->parameter('ExcitationWavelength');
        $value = $parameter->value();
        $ex = $value[$mostRestrictiveChannel];

        $parameter = $this->parameter('NumericalAperture');
        $na = (float) $parameter->value();

        $parameter = $this->parameter('MicroscopeType');
        $micr = $parameter->translatedValue();

        $parameter = $this->parameter('ObjectiveType');
        $ril = $parameter->translatedValue();

        if ($this->isTwoPhoton()) {
            $pcnt = 2;
        } else {
            $pcnt = 1;
        }
        // Only micr, na, em, ex and pcnt are necessary to calculate it.
        if ($micr == null || $na == null || $em == null ||
                $ex == null || $ril == null) {
            return false;
        }
        $opt = "-micr $micr -na $na -em $em -ex $ex -pcnt $pcnt -ril $ril";
        $ideal = askHuCore("calculateNyquistRate", $opt);
        // print_r($ideal);
        return array($ideal['xy'], $ideal['z']);
    }

    /*!
      \brief	Returns all 3-D geometries (i.e. 'XYZ', 'XYZ - time')
      \return	the 3D geometries
    */
    public function threeDimensionalGeometries() {
        static $threeDimensionalGeometries;
        if ($threeDimensionalGeometries == NULL) {
            $db = new DatabaseConnection();
            $threeDimensionalGeometries = $db->geometriesWith(True, NULL);
        }
        return $threeDimensionalGeometries;
    }

    /*!
      \brief	Returns all time series geometries (i.e. 'XY - time', 'XYZ - time')
      \return	the time series geometries
    */
    public function timeSeriesGeometries() {
        static $timeSeriesGeometries;
        if ($timeSeriesGeometries == NULL) {
            $db = new DatabaseConnection();
            $timeSeriesGeometries = $db->geometriesWith(NULL, True);
        }
        return $timeSeriesGeometries;
    }

    /*!
      \brief	Returns all fixed geometry file formats (i.e. those that are 2D)
      \return	the fixed geometry file formats
    */
    public function fixedGeometryFileFormats() {
        static $fixedGeometryFileFormats;
        if ($fixedGeometryFileFormats == NULL) {
            $db = new DatabaseConnection();
            $fixedGeometryFileFormats = $db->fileFormatsWith(NULL, NULL, True);
        }
        return $fixedGeometryFileFormats;
    }

    /*!
      \brief	Checks whether currently chosen file format has fixed geometry
      \return	true if the chosen file format has fixed geometry, false otherwise
    */
    public function isFixedGeometryFormat() {
        $param = $this->parameter('ImageFileFormat');
        $result = in_array($param->value(), $this->fixedGeometryFileFormats());
        return $result;
    }

    /*!
      \brief	Returns the file formats that support single channel images
      \return	array of file formats
    */
    public function singleChannelFileFormats() {
        static $singleChannelFileFormats;
        if ($singleChannelFileFormats == NULL) {
            $db = new DatabaseConnection();
            $singleChannelFileFormats = $db->fileFormatsWith(True, NULL, NULL);
        }
        return $singleChannelFileFormats;
    }

    /*!
      \brief	Returns the file formats that support multi-channel images
      \return	array of file formats
    */
    public function multiChannelFileFormats() {
        static $multiChannelFileFormats;
        if ($multiChannelFileFormats == NULL) {
            $db = new DatabaseConnection();
            $multiChannelFileFormats = $db->fileFormatsWith(False, NULL, NULL);
        }
        return $multiChannelFileFormats;
    }

    /*!
      \brief	Returns the file formats that support a variable number of channels
              per file
      \return	array of file formats
    */
    public function variableChannelFileFormats() {
        static $variableChannelFileFormats;
        if ($variableChannelFileFormats == NULL) {
            $db = new DatabaseConnection();
            $variableChannelFileFormats =
                $db->fileFormatsWith(NULL, True, NULL);
        }
        return $variableChannelFileFormats;
    }

    /*!
      \brief	Checks whether current Setting is for multi-channel file formats
      \return	true if the number of channels set for current Setting is > 1,
              false otherwise
    */
    public function isMultiChannel() {
        $parameter = $this->parameter('NumberOfChannels');
        $num_channels = (int) $parameter->value();
        if ($num_channels > 1) {
            $result = True;
        } else {
            $result = False;
        }
        return $result;
    }

    /*!
      \brief	Checks whether currently selected file format is variable channel
      \return	true if the currently selected file format is variable channel
      \see variableChannelFileFormats()
    */
    function isVariableChannelFormat() {
        $result = False;
        $parameter = $this->parameter('ImageFileFormat');
        if (in_array($parameter->value(), $this->variableChannelFileFormats())) {
            $result = True;
        }
        return $result;
    }

    /*!
      \brief	Checks whether currently selected file format is one of the
              TIFF variants
      \return	true if the currently selected file format is a TIFF variant
    */
    public function isTif() {
        $result = False;
        $parameter = $this->parameter('ImageFileFormat');
        if (strstr($parameter->value(), 'tif'))
            $result = True;
        return $result;
    }

    /*!
      \brief	Returns the number of channels of the Setting
      \return	the number of channels
    */
    public function numberOfChannels() {
        $parameter = $this->parameter('NumberOfChannels');
        if ($parameter) {
            return ( (int) $parameter->value() );
        } else {
            return ( (int) 1 );
        }
    }

    /*!
      \brief  Returns the main microscope mode.
      \return Whether confocal, widefield, STED, STED 3D, spinning disk or
              multiphoton.
    */
    public function microscopeType( ) {
        $parameter = $this->parameter('MicroscopeType');
        if ($parameter) {
            return $parameter->value();
        } else {
            return NULL;
        }
    }

    /*!
      \brief	Checks whether the currently selected microscope type is spinning
              (Nipkow) disk confocal
      \return	true if the currently selected microscope type is spinning (Nipkow)
              disk, false otherwise
    */
    public function isNipkowDisk() {
        return $this->isMultiPointConfocal();
    }

    /*!
      \brief	Checks whether the currently selected microscope type is 2-Photon
      \return	true if the currently selected microscope type is 2-Photon,
              false otherwise
    */
    public function isTwoPhoton() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value == 'two photon');
    }

    /*!
      \brief	Checks whether the currently selected microscope type is
              single-point confocal
      \return	true if the currently selected microscope type is single-point
              confocal, false otherwise
    */
    public function isSinglePointConfocal() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value == 'single point confocal');
    }

    /*!
      \brief   Checks whether the currently selected microscope type is sted.
      \return  true if the currently selected microscope type is sted, false
               otherwise.
    */
    public function isSted() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value === 'STED');
    }

    /*!
      \brief   Checks whether the currently selected microscope type is sted 3D.
      \return  true if the currently selected microscope type is sted 3D, false
               otherwise.
    */
    public function isSted3D() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value === 'STED 3D');
    }

    /*!
      \brief   Checks whether the currently selected microscope type is spim.
      \return  true if the currently selected microscope type is spim, false
               otherwise.
    */
    public function isSpim() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value === 'SPIM');
    }


    /*!
      \brief	Checks whether the currently selected microscope type is spinning
              (Nipkow) disk confocal
      \return	true if the currently selected microscope type is spinning (Nipkow)
              disk, false otherwise
    */

    public function isMultiPointConfocal() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value == 'multipoint confocal (spinning disk)');
    }

    /*!
      \brief	Checks whether the currently selected microscope type is widefield
      \return	true if the currently selected microscope type is widefield,
              false otherwise
    */
    public function isWidefield() {
        $parameter = $this->parameter('MicroscopeType');
        $value = $parameter->value();
        return ($value == 'widefield');
    }

    /*!
      \brief	Checks whether the currently selected microscope type is either
              widefield of spinning disk
      \return	true if the currently selected microscope type is either widefield
              of spinning disk, false otherwise
    */
    public function isWidefieldOrMultiPoint() {
        return ($this->isWidefield() || $this->isMultiPointConfocal());
    }

    /*!
      \brief	Checks whether the currently selected microscope type is either
              2-Photon or single-point confocal
      \return	true if the currently selected microscope type is either 2-Photon
              or single-point confocal, false otherwise
    */
    public function isTwoPhotonOrSinglePoint() {
        return ($this->isSinglePointConfocal() || $this->isTwoPhoton());
    }

    /*!
      \brief	Checks whether the currently selected microscope type is any type
              of confocal
      \return	true if the currently selected microscope type is any type of
              confocal, false otherwise
    */
    public function isMultiPointOrSinglePointConfocal() {
        return ($this->isSinglePointConfocal() ||
                $this->isMultiPointConfocal());
    }

    /*!
    \brief    This determines which microscope types have a pinhole
    \return   True if the microscope contains a pinhole. False otherwise.
    */
    public function hasPinhole() {
        if ($this->isMultiPointOrSinglePointConfocal()) {
            return True;
        } elseif ($this->isSted()) {
            return True;
        } elseif ($this->isSted3D()) {
            return True;
        } else {
            return False;
        }
    }

    /*!
      \brief	Returns the pixel size (the value of CCDCaptorSizeX) in nm
      \todo	This is redundant!
      \return	pixel size in nm
    */
    public function pixelSize() {
        $param = $this->parameter('CCDCaptorSizeX');
        $size = (float) $param->value();
        return $size;
    }

    /*!
      \brief	Returns the sample size in X direction in um

      This is simply pixelSize() / 1000.

      \return	sample size in um
    */
    public function sampleSizeX() {
        $size = $this->pixelSize();
        return $size / 1000;
    }

    /*!
      \brief	Returns the sample size in Y direction in um

      This just returns the value in X direction.

      \return	sample size in um
    */
    public function sampleSizeY() {
        return $this->sampleSizeX();
    }

    /*!
      \brief	Returns the sample size in um in Z direction

      This is the value of the z-step size / 1000.

      \return	sample size in um
    */
    public function sampleSizeZ() {
        $param = $this->parameter('ZStepSize');
        $size = (float) $param->value();
        return $size / 1000;
    }

    /*!
      \brief	Returns the time interval between consecutive time points in a time
              series in seconds
      \return	time interval in seconds
    */
    public function sampleSizeT() {
        $param = $this->parameter('TimeInterval');
        $size = (float) $param->value();
        return $size / 1;
    }

    /*!
      \brief  Get the list of templates shared with the given user.
      \param String $username Name of the user to query for.
      \return	list of shared templates with the user.
    */
    public static function getTemplatesSharedWith($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedWith($username, self::sharedTable());
        return $result;
    }

    /*!
      \brief  Get the list of templates shared by the given user.
      \param String $username Name of the user to query for.
      \return	list of shared templates by the user.
    */
    public static function getTemplatesSharedBy($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedBy($username, self::sharedTable());
        return $result;
    }

    /*!
      \brief Huygens parameters to HRM parameters.
      \param $huArray An array with the result of 'image setp -tclReturn'.
    */
    public function parseParamsFromHuCore($huArray){

         // Sanity checks: remove trailing spaces.
        foreach ($huArray as $key => $value) {
            $huArray[$key] = trim($value, " ");
        }

        // Microscope Type.
        if (strpos($huArray['parState,micr'], "default") === FALSE) {
            $huMicrType = explode(" ", $huArray['micr'], 5);
            $hrmMicrType = $this->parameter['MicroscopeType'];

            // By default, take the first value.
            $micrVal = $hrmMicrType->translateHucore($huMicrType[0]);

            // If there is STED, just make sure that it's the right one.
            if(array_search('sted', $huMicrType)) {
                $micrVal = $hrmMicrType->translateHucore('sted');
            }
            if(array_search('sted3d', $huMicrType)) {
                $micrVal = $hrmMicrType->translateHucore('sted3d');
            }

            $hrmMicrType->setValue($micrVal);
        } 

        // Number of channels.
        if (isset($huMicrType)) {
            $chanCnt = count($huMicrType);
        } else {
            $chanCnt = 1;
        }
        
        if ($chanCnt > 5) $chanCnt = 5;
        $this->parameter['NumberOfChannels']->setValue($chanCnt);

        // Sampling sizes.
        if (strpos($huArray['parState,s'], "default") === FALSE) {
            $sampleSizes = array_map('floatval',  explode(' ', $huArray['s']));
            
            $sampleSizes[0] = round($sampleSizes[0] * 1000);
            $this->parameter['CCDCaptorSizeX']->setValue($sampleSizes[0]);
            
            $sampleSizes[2] = round($sampleSizes[2] * 1000);
            $this->parameter['ZStepSize']->setValue($sampleSizes[2]);
            
            $this->parameter['TimeInterval']->setValue($sampleSizes[3]);
        }
        
        // Numerical Aperture.
        if (strpos($huArray['parState,na'], "default") === FALSE) {
            $na = explode(" ", $huArray['na'], 5);
            $this->parameter['NumericalAperture']->setValue($na[0]);
        }

        // Objective Type.
        if (strpos($huArray['parState,ril'], "default") === FALSE) {
            $lensImm = array_map('floatval',
                                 explode(' ', $huArray['ril']));
            $this->parameter['ObjectiveType']->setValue($lensImm[0]);
        }

        // Sample Medium.
        if (strpos($huArray['parState,ri'], "default") === FALSE) {
            $embMedium = array_map('floatval',
                                   explode(' ', $huArray['ri']));
            $this->parameter['SampleMedium']->setValue($embMedium[0]);
        }

        // Excitation Wavelength.
        if (strpos($huArray['parState,ex'], "default") === FALSE) {
            $lambdaEx = array_map('intval',
                                  explode(' ', $huArray['ex']));
            $this->parameter['ExcitationWavelength']->setValue($lambdaEx);
        }
        
        // Emission Wavelength.
        if (strpos($huArray['parState,em'], "default") === FALSE) {
            $lambdaEm = array_map('intval',
                                  explode(' ', $huArray['em']));
            $this->parameter['EmissionWavelength']->setValue($lambdaEm);
        }

        // Pinhole size.
        if (strpos($huArray['parState,pr'], "default") === FALSE) {
            $pinhole = array_map('intval',
                                 explode(' ', $huArray['pr']));
            $this->parameter['PinholeSize']->setValue($pinhole);
        }

        // Pinhole spacing.
        if (strpos($huArray['parState,ps'], "default") === FALSE) {
            $phSpacing = array_map('floatval',
                                   explode(' ', $huArray['ps']));
            $this->parameter['PinholeSpacing']->setValue($phSpacing[0]);
        }

        // Coverslip Relative Position.
        if (strpos($huArray['parState,imagingDir'], "default") === FALSE) {
            // Downward is closest.
            $imagingDir   = explode(' ', $huArray['imagingDir']);
            $coversPos = "farthest";
            if (strcmp("downward", $imagingDir[0])) {
                $coversPos = "closest";
            }
            $this->parameter['CoverslipRelativePosition']->setValue($coversPos);
        }

        // STED Depletion Mode.
        if (strpos($huArray['parState,stedMode'], "default") === FALSE) {
            $stedMode = explode(' ', $huArray['stedMode']);

            // Rename some modes if the mType is set to confocal.
            for($i = 0; $i < count($stedMmode); $i++) {
                if($huMicrType[$i] == 'confocal') {
                    $stedMode[$i] = 'off-confocal';
                }
            }
            $this->parameter['StedDepletionMode']->setValue($stedMode);
        }

        // STED Saturation Factor.
        if (strpos($huArray['parState,stedSatFact'], "default") === FALSE) {
            $stedSatFact = array_map('floatval',
                                     explode(' ', $huArray['stedSatFact']));
            $this->parameter['StedSaturationFactor']->setValue($stedSatFact);
        }

        // STED Wavelength.
        if (strpos($huArray['parState,stedLambda'], "default") === FALSE) {
            $stedLambda = array_map('floatval',
                                    explode(' ', $huArray['stedLambda']));
            $this->parameter['StedWavelength']->setValue($stedLambda);
        }
        
        // STED Immunity Fraction.
        if (strpos($huArray['parState,stedImmunity'], "default") === FALSE) {
            $stedImmunity = array_map('floatval',
                                      explode(' ', $huArray['stedImmunity']));
            $this->parameter['StedImmunity']->setValue($stedImmunity);
        }

        // Whether STED is STED3D.
        if (strpos($huArray['parState,sted3D'], "default") === FALSE) {
            $sted3d = array_map('floatval',
                                explode(' ', $huArray['sted3D']));
            $this->parameter['Sted3D']->setValue($sted3d);
        }


        /* Comment out after merging with SPIM branch. */
        
        // // SPIM Excitation Mode.
        // if (strpos($huArray['parState,spimExc'], "default") === FALSE) {
        //     $spimExcMode = array_map('floatval',
        //                              explode(' ', $huArray['spimExc']));
        //     $this->parameter['SpimExcMode']->setValue($spimExcMode);
        // }

        // // SPIM Gaussian Width.
        // if (strpos($huArray['parState,spimGaussWidth'], "default") === FALSE) {
        //     $spimGaussWidth = array_map('floatval',
        //                              explode(' ', $huArray['spimGaussWidth']));
        //     $this->parameter['SpimGaussWidth']->setValue($spimGaussWidth);
        // }

        // // SPIM Center Offset.
        // if (strpos($huArray['parState,spimCenterOff'], "default") === FALSE) {
        //     $spimCenterOff = array_map('floatval',
        //                                explode(' ', $huArray['spimCenterOff']));
        //     $this->parameter['SpimCenterOffset']->setValue($spimCenterOff);
        // }

        // // SPIM Focus Offset.
        // if (strpos($huArray['parState,spimFocusOff'], "default") === FALSE) {
        //     $spimFocusOff = array_map('floatval',
        //                               explode(' ', $huArray['spimFocusOff']));
        //     $this->parameter['SpimFocusOffset']->setValue($spimFocusOff);
        // }

        // // SPIM NA.
        // if (strpos($huArray['parState,spimNA'], "default") === FALSE) {
        //     $spimNA = array_map('floatval',
        //                         explode(' ', $huArray['spimNA']));
        //     $this->parameter['SpimNA']->setValue($spimNA);
        // }
        
        // // SPIM Fill Factor.
        // if (strpos($huArray['parState,spimFill'], "default") === FALSE) {
        //     $spimFill = array_map('floatval',
        //                         explode(' ', $huArray['spimFill']));
        //     $this->parameter['SpimFill']->setValue($spimFill);
        // }

        // // SPIM Imaging Direction.
        // if (strpos($huArray['parState,spimDir'], "default") === FALSE) {
        //     $spimDir = array_map('floatval',
        //                          explode(' ', $huArray['spimDir']));
        //     $this->parameter['SpimDir']->setValue($spimDir);
        // }
    }
}

/*
 ============================================================================
 */

/*!
  \class	TaskSetting
  \brief	A TaskSetting is a complete set of restoration parameters
*/
class TaskSetting extends Setting {

    /*!
      \var	$numberOfChannels
      \brief	Number of channels for the parameters of the TaskSetting
    */

    /*!
      \brief	Constructor: constructs and initializes a TaskSetting
    */
    public function TaskSetting() {
        parent::__construct();

        $parameterClasses = array(
            'Autocrop',
            'SignalNoiseRatio',
            'BackgroundOffsetPercent',
            'NumberOfIterations',
            'OutputFileFormat',
            'MultiChannelOutput',
            'QualityChangeStoppingCriterion',
            'DeconvolutionAlgorithm',
            'ZStabilization',
            'ChromaticAberration');

        foreach ($parameterClasses as $class) {
            $param = new $class;
            $name = $param->name();

            $this->parameter[$name] = $param;
            $this->numberOfChannels = NULL;
        }
    }

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag. This is an abstract function and must
      be reimplemented.
    */
    public static function table() {
        return "task_setting";
    }

    /*!
      \brief	Returns the name of the database table in which the list of
      shared Setting names are stored.
    */
    public static function sharedTable() {
        return "shared_task_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()

      This is an abstract function and must be reimplemented.

      \see table()
    */
    public static function parameterTable() {
        return "task_parameter";
    }

    /*!
    \brief	Returns the name of the database table to use for sharing
            settings.
    \see table()
    */
    public static function sharedParameterTable() {
        return "shared_task_parameter";
    }

    /*!
      \brief	Checks that the posted Task Parameters are all defined
              and valid
      \param	$postedParameters	The $_POST array
    */
    public function checkPostedTaskParameters($postedParameters) {
        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();

        $this->message = '';
        $noErrorsFound = True;

        // Get the names of the relevant parameters
        $names = $this->taskParameterNames();

        // Deconvolution Algorithm - this should always be defined, but since
        // other parameters depend on it, in case it is not defined we return
        // here
        if (!isset($postedParameters["DeconvolutionAlgorithm"])) {
            $this->message = 'Please choose a deconvolution algorithm!';
            return False;
        }

        // Set the Parameter and check the value
        $parameter = $this->parameter("DeconvolutionAlgorithm");
        $parameter->setValue($postedParameters["DeconvolutionAlgorithm"]);
        $this->set($parameter);
        if (!$parameter->check()) {
            $this->message = 'Unknown deconvolution algorithm!';
            return False;
        }
        $algorithm = strtoupper($parameter->value());

        // Signal-To-Noise Ratio
        // Depending on the choice of the deconvolution algorithm, we will
        // check only the relevant entries
        for ($i = 0; $i < $maxChanCnt; $i++) {
            $value[$i] = null;
            $name = "SignalNoiseRatio" . $algorithm . "$i";
            if (isset($postedParameters[$name])) {
                $value[$i] = $postedParameters[$name];
            }
        }
        $parameter = $this->parameter("SignalNoiseRatio");
        $parameter->setValue($value);
        $this->set($parameter);
        if (!$parameter->check()) {
            $this->message = $parameter->message();
            $noErrorsFound = False;
        }

        // Background estimation
        if (!isset($postedParameters["BackgroundEstimationMode"]) ||
                $postedParameters["BackgroundEstimationMode"] == '') {
            $this->message = 'Please choose a background estimation mode!';
            $noErrorsFound = False;
        } else {
            $value = array_fill(0, $maxChanCnt, null);
            switch ($postedParameters["BackgroundEstimationMode"]) {
                case 'auto':

                    $value[0] = 'auto';
                    break;

                case 'object' :

                    $value[0] = 'object';
                    break;

                case 'manual' :

                    for ($i = 0; $i < $maxChanCnt; $i++) {
                        $value[$i] = null;
                        $name = "BackgroundOffsetPercent$i";
                        if (isset($postedParameters[$name])) {
                            $value[$i] = $postedParameters[$name];
                        }
                    }
                    break;

                default :
                    $this->message = 'Unknown background estimation mode!';
                    $noErrorsFound = False;
            }
            $parameter = $this->parameter("BackgroundOffsetPercent");
            $parameter->setValue($value);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        // Number of iterations
        if (isset($postedParameters["NumberOfIterations"]) ||
                $postedParameters["NumberOfIterations"] == '') {
            $parameter = $this->parameter("NumberOfIterations");
            $parameter->setValue($postedParameters["NumberOfIterations"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        // Quality change
        if (isset($postedParameters["QualityChangeStoppingCriterion"]) ||
                $postedParameters["QualityChangeStoppingCriterion"] == '') {
            $parameter = $this->parameter("QualityChangeStoppingCriterion");
            $parameter->setValue($postedParameters["QualityChangeStoppingCriterion"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        // Stabilization in Z
        if (isset($postedParameters["ZStabilization"]) ||
                $postedParameters["ZStabilization"] == '') {
            $parameter = $this->parameter("ZStabilization");
            $parameter->setValue($postedParameters["ZStabilization"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        // Autocrop
        if (isset($postedParameters["Autocrop"]) ||
                $postedParameters["Autocrop"] == '') {
            $parameter = $this->parameter("Autocrop");
            $parameter->setValue($postedParameters["Autocrop"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        return $noErrorsFound;
    }

    /*!
      \brief   Checks that the posted Aberration Correction Parameters are 
               defined. This correction is optional.
      \param   $postedParameters    The $_POST array
      \return  true if all Parameters are defined and valid, false otherwise.
    */
    public function checkPostedChromaticAberrationParameters($postedParameters) {

        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $this->message = '';
        $noErrorsFound = True;

        foreach ($postedParameters as $param) {
            if ($param != "" && !is_numeric($param)) {
                $noErrorsFound = False;
                $this->message = "Value must be numeric";
                break;
            }
        }

        if (!$noErrorsFound) {
            return $noErrorsFound;
        }

        $parameter = $this->parameter("ChromaticAberration");

        /* The posted parameters are received in increasing 'chan component'
           order. */
        $i = 0;
        foreach ($postedParameters as $name => $param) {
            if (strpos($name, 'ChromaticAberration') === false) {
                continue;
            }

            $valuesArray[$i] = $param;
            $i++;
        }
        
        $parameter->setValue($valuesArray);
        
        return $noErrorsFound;
    }
    
    
    /*!
      \brief	Returns all Task Parameter names
      \return array of Task Parameter names
    */
    public function taskParameterNames() {
        $names = array();
        foreach ($this->parameter as $parameter) {
            if ($parameter->isTaskParameter()) {
                $names[] = $parameter->name();
            }
        }
        return $names;
    }

    /*!
      \brief	Returns the number of channels of the Setting
      \return	the number of channels for the Setting
    */
    public function numberOfChannels() {
        return $this->numberOfChannels;
    }

    /* !
      \brief  Displays the setting as a text containing Parameter names
              and their values
      \param	$numberOfChannels Number of channels (optional, default
              value is 0)
     */
    public function displayString($numberOfChannels = 0, $micrType = NULL) {
        $result = '';
        $algorithm = $this->parameter('DeconvolutionAlgorithm')->value();
        foreach ($this->parameter as $parameter) {
            if ($parameter->name() == 'SignalNoiseRatio') {
                $parameter->setAlgorithm($algorithm);
            }
            if ($parameter->name() == 'OutputFileFormat') {
                continue;
            }
            if ($parameter->name() == 'MultiChannelOutput') {
                continue;
            }
            if ($parameter->name() == 'ZStabilization'
                &&  !strstr($micrType,"STED")) {
                continue;
            }
            $result = $result .
                $parameter->displayString($numberOfChannels);
        }
        return $result;
    }

    /*!
      \brief   Checks whether the restoration should allow for stabilization.
      \param   $paramSetting An instance of the ParameterSetting class.
      \return  Boolean: TRUE to enable stabilization option, FALSE otherwise.
    */
    public function isEligibleForStabilization(ParameterSetting $paramSetting) {

        if (!$paramSetting->isSted() && !$paramSetting->isSted3D()) {
            return FALSE;
        }
        if ($paramSetting->parameter("ZStepSize")->value() === '0') {
            return FALSE;
        }
        if (!System::hasLicense("stabilizer")) {
            return FALSE;
        }
        if (!System::hasLicense("sted")) {
            return FALSE;
        }
        if (!System::hasLicense("sted3d")) {
            return FALSE;
        }
        return TRUE;
    }

    /*!
      \brief   Checks whether the restoration should allow for CAC.
      \param   $paramSetting  An instance of the ParameterSetting class.
      \return  Boolean: TRUE to enable CAC, FALSE otherwise.
    */
    public function isEligibleForCAC(ParameterSetting $paramSetting) {
        if ($this->numberOfChannels() == 1) {
            return FALSE;
        }
        if (!System::hasLicense("chromaticS")) {
            return FALSE;
        }

        return TRUE;
    }


    /*!
      \brief  Get the list of templates shared with the given user.
      \param String $username Name of the user to query for.
      \return	list of shared templates with the user.
    */
    public static function getTemplatesSharedWith($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedWith($username, self::sharedTable());
        return $result;
    }

    /*!
    \brief  Get the list of templates shared by the given user.
    \param String $username Name of the user to query for.
    \return	list of shared templates by the user.
    */
    public static function getTemplatesSharedBy($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedBy($username, self::sharedTable());
        return $result;
    }


    /*!
      \brief Huygens parameters to HRM parameters.
      \param $huArray An array with the result of 'image setp -tclReturn'.
    */
    public function parseParamsFromHuCore($huArray){

         // Sanity checks: remove trailing spaces.
        foreach ($huArray as $key => $value) {
            $huArray[$key] = trim($value, " ");
        }

        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();

        // We only look at the first channel for the decon algorithm.
        if (strpos($huArray['cmle:0'], "") === FALSE) {
            $algorithm = $this->parameter('DeconvolutionAlgorithm');
            $algorithm->setValue("cmle");
        } else if (strpos($huArray['qmle:0'], "") === FALSE) {
            $algorithm = $this->parameter('DeconvolutionAlgorithm');
            $algorithm->setValue("qmle");
        }

        // SNR.
        for ($chan = 0; $chan < $maxChanCnt; $chan++) {
            if ($this->parameter('DeconvolutionAlgorithm')->value() == "cmle") {
                $key = "cmle:" . $chan . " sn";
            } else {
                $key = "qmle:" . $chan . " sn";
            }

            if (strpos($huArray[$key], "") === FALSE) {
                $snr[$chan] = $huArray[$key];
            }
        }
        if (isset($snr)) {
            $this->parameter['SignalNoiseRatio']->setValue($snr);
        }

        // Autocrop.
        if (strpos($huArray['autocrop enabled'],"") === FALSE) {
            $autocrop = $huArray['autocrop enabled'];
            $this->parameter['Autocrop']->setValue($autocrop);
        }

        // Background.
        // Set it to manual only if all channels are specified.
        // Otherwise set it to the first other mode encountered.
        for ($chan = 0; $chan < $maxChanCnt; $chan++) {
            $keyCmleBgMode = "cmle:" . $chan . " bgMode";
            $keyQmleBgMode = "qmle:" . $chan . " bgMode";
            $keyCmleBgVal  = "cmle:" . $chan . " bg";
            $keyQmleBgVal  = "qmle:" . $chan . " bg";

            if (isset($huArray[$keyCmleBgMode])) {
                $bgMode = $huArray[$keyCmleBgMode];
            } else if (isset($huArray[$keyQmleBgMode])) {
                $bgMode = $huArray[$keyQmleBgMode];
            } else {
                $bgMode = "auto";
            }

            if (isset($huArray[$keyCmleBgVal])) {
                $bgVal = $huArray[$keyCmleBgVal];
            } else if (isset($huArray[$keyQmleBgVal])) {
                $bgVal = $huArray[$keyQmleBgVal];
            } else {
                $bgVal = 0.;
            }

            if ($bgMode == "auto" || $bgMode == "object") {
                $bgArr = array_fill(0, $maxChanCnt, $bgMode);
                break;
            } else if ($bgMode == "lowest" || $bgMode == "widefield") {
                $bgArr = array_fill(0, $maxChanCnt, "auto");
                break;
            } else if ($bgMode == "manual") {
                $bgArr[$chan] = $bgVal;
            } else {
                $bgArr = array_fill(0, $maxChanCnt, "auto");
                break;
            }
        }
        $this->parameter['BackgroundOffsetPercent']->setValue($bgArr);

        // Iterations.
        for ($chan = 0; $chan < $maxChanCnt; $chan++) {
            if ($this->parameter('DeconvolutionAlgorithm')->value() == "cmle") {
                $key = "cmle:" . $chan . " it";
            } else {
                $key = "qmle:" . $chan . " it";
            }

            if (strpos($huArray[$key], "") === FALSE) {
                $it = $huArray[$key];
                $itOld = $this->parameter['NumberOfIterations']->value();
                if ($it > $itOld) {
                    $this->parameter['NumberOfIterations']->setValue($it);
                }
            }
        }

        // Quality factor.
        for ($chan = 0; $chan < $maxChanCnt; $chan++) {
            if ($this->parameter('DeconvolutionAlgorithm')->value() == "cmle") {
                $key = "cmle:" . $chan . " q";
            } else {
                $key = "qmle:" . $chan . " q";
            }
            
            if (strpos($huArray[$key], "") === FALSE) {
                $q = $huArray[$key];
                $key = 'QualityChangeStoppingCriterion';
                $qOld = $this->parameter[$key]->value();
                if ($q > $qOld) {
                    $this->parameter[$key]->setValue($q);
                }
            }
        }

        // Stabilization.
        if (strpos($huArray['stabilize enabled'],"") === FALSE) {
            $stabilize = $huArray['stabilize enabled'];
            $this->parameter['ZStabilization']->setValue($stabilize);
        }

        // Chromatic Aberration.
        $compCnt = 5;
        for ($chan = 0; $chan < $maxChanCnt; $chan++) {
            $key = "shift:" . $chan . " vector";

            unset($vector);
            if (isset($huArray[$key])) {
                $vector = explode(" ", $huArray[$key], $compCnt);
            }
            
            for ($comp = 0; $comp < $compCnt; $comp++) {
                $compKey = $chan * $compCnt + $comp;
                
                if (isset($vector[$comp])) {
                    $aberration[$compKey] = $vector[$comp];
                } else {
                    if ($comp < $compCnt - 1) {
                        $aberration[$compKey] = 0.;
                    } else {
                        // Scale component.
                        $aberration[$compKey] = 1.;
                    }
                }
            }
        }
        if (isset($aberration)) {
            $this->parameter['ChromaticAberration']->setValue($aberration);
        }
    }

    
} // End of class taskSetting

/*
 ============================================================================
 */

/*!
  \class	AnalysisSetting
  \brief	An AnalysisSetting is a complete set of analysis parameters
*/
class AnalysisSetting extends Setting {

    /*!
      \var	$numberOfChannels
      \brief	Number of channels for the parameters of the TaskSetting
    */

    /*!
      \brief	Constructor: constructs and initializes an AnalysisSetting
    */
    public function AnalysisSetting() {
        parent::__construct();
        $parameterClasses = array(
            'ColocAnalysis',
            'ColocChannel',
            'ColocCoefficient',
            'ColocThreshold',
            'ColocMap',
        );

        foreach ($parameterClasses as $class) {
            $param = new $class;
            $name = $param->name();
            $this->parameter[$name] = $param;
            $this->numberOfChannels = NULL;
        }
    }

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag. This is an abstract function and must
      be reimplemented.
    */
    public static function table() {
        return "analysis_setting";
    }

    /*!
      \brief	Returns the name of the database table in which the list of
      shared Setting names are stored.
    */
    public static function sharedTable() {
        return "shared_analysis_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()

      This is an abstract function and must be reimplemented.

      \see table()
    */
    public static function parameterTable() {
        return "analysis_parameter";
    }

    /*!
      \brief	Returns the name of the database table to use for sharing
                settings.
      \see table()
    */
    public static function sharedParameterTable() {
        return "shared_analysis_parameter";
    }

    /*!
      \brief	Checks that the posted analysis Parameters are all
                defined and valid
      \param	$postedParameters	The $_POST array
    */
    public function checkPostedAnalysisParameters($postedParameters) {
        if (count($postedParameters) == 0) {
            $this->message = '';
            return False;
        }

        $db = new DatabaseConnection;
        $maxChanCnt = $db->getMaxChanCnt();

        $this->message = '';
        $noErrorsFound = True;

        $parameter = $this->parameter("ColocAnalysis");
        $parameter->setValue($postedParameters["ColocAnalysis"]);
        $this->set($parameter);

        if ($parameter->value() == False) {
            return $noErrorsFound;
        }

            // At least two channels must be selected.
        if (!isset($postedParameters["ColocChannel"])
            || $postedParameters["ColocChannel"] == "") {
            $this->message  = "Please indicate the channels (at least two) for ";
            $this->message .= "colocalization analysis.";
            return False;
        } else {
            $parameter = $this->parameter("ColocChannel");
            $parameter->setValue($postedParameters["ColocChannel"]);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                return False;
            }
        }

            // At least one coefficient must be selected.
        if (!isset($postedParameters["ColocCoefficient"])
            || $postedParameters["ColocCoefficient"] == "") {
            $this->message  = "Please indicate the coefficients for ";
            $this->message .= "colocalization analysis.";
            return False;
        } else {
            $parameter = $this->parameter("ColocCoefficient");
            $parameter->setValue($postedParameters["ColocCoefficient"]);
            $this->set($parameter);
        }

          // Colocalizastion threshold mode
        if (!isset($postedParameters["ColocThresholdMode"]) ||
                $postedParameters["ColocThresholdMode"] == '') {
            $this->message = 'Please choose a colocalization threshold mode!';
            $noErrorsFound = False;
        } else {
            $value = array_fill(0, $maxChanCnt, null);
            switch ($postedParameters["ColocThresholdMode"]) {
                case 'auto':

                    $value[0] = 'auto';
                    break;

                case 'manual' :

                    for ($i = 0; $i < $maxChanCnt; $i++) {
                        $value[$i] = null;
                        $name = "ColocThreshold$i";
                        if (isset($postedParameters[$name])) {
                            $value[$i] = $postedParameters[$name];
                        }
                    }
                    break;

                default :
                    $this->message = 'Unknown colocalization threshold mode!';
                    $noErrorsFound = False;
            }

            $parameter = $this->parameter("ColocThreshold");
            $parameter->setValue($value);
            $this->set($parameter);
            if (!$parameter->check()) {
                $this->message = $parameter->message();
                $noErrorsFound = False;
            }
        }

        $parameter = $this->parameter("ColocMap");
        $parameter->setValue($postedParameters["ColocMap"]);
        $this->set($parameter);

        return $noErrorsFound;
    }

    /*!
      \brief	Returns the number of channels of the Setting
      \return	the number of channels for the Setting
    */
    public function numberOfChannels() {
        return $this->numberOfChannels;
    }

    /* !
      \brief  Displays the setting as a text containing Parameter names
              and their values
      \param	$numberOfChannels Number of channels (optional, default
              value is 0)
     */
    public function displayString($numberOfChannels = 0, $micrType = NULL) {
        $result = '';

        $colocAnalysis = $this->parameter("ColocAnalysis")->value();
        foreach ($this->parameter as $parameter) {

            if ($parameter->name() != "ColocAnalysis"
                && $colocAnalysis == False) {
                continue;
            }

            $result = $result .
                $parameter->displayString($this->numberOfChannels());
        }
        return $result;
    }


    /*!
      \brief  Get the list of templates shared with the given user.
      \param String $username Name of the user to query for.
      \return	list of shared templates with the user.
    */
    public static function getTemplatesSharedWith($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedWith($username, self::sharedTable());
        return $result;
    }

    /*!
    \brief  Get the list of templates shared by the given user.
    \param String $username Name of the user to query for.
    \return	list of shared templates by the user.
    */
    public static function getTemplatesSharedBy($username) {
        $db = new DatabaseConnection();
        $result = $db->getTemplatesSharedBy($username, self::sharedTable());
        return $result;
    }

} // End of class analysisSetting

/*
 ============================================================================
 */

/*!
  \class	JobParameterSetting
  \brief	A parameter setting is a complete set of microscope,
          image and capture parameters.

  A JobParameterSetting is a parameter setting that is used when a Job is
  executed by the queue manager. It uses different database tables and knows
  how to put its parameter settings onto a script.
*/
class JobParameterSetting extends ParameterSetting {

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag.
    */
    public static function table() {
        return "job_parameter_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()
      \see table()
    */
    public static function parameterTable() {
        return "job_parameter";
    }

} // End of class JobParameterSetting

/*
 ============================================================================
 */

/*!
  \class	JobTaskSetting
  \brief	A job task setting is a complete set of restoration parameters that
          is used when a job is processed by the queue manager.
*/
class JobTaskSetting extends TaskSetting {

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag.
    */
    public static function table() {
        return "job_task_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()
      \see table()
    */
    public static function parameterTable() {
        return "job_task_parameter";
    }

} // End of class JobTaskSetting

/*
 ============================================================================
 */

/*!
  \class	JobAnalysisSetting
  \brief	A job analysis setting is a complete set of analysis parameters
                that is used when a job is processed by the queue manager.
*/
class JobAnalysisSetting extends AnalysisSetting {

    /*!
      \brief	Returns the name of the database table in which the list of
              Setting names are stored.

      Besides the name, the table contains the Setting's name, owner and
      the standard (default) flag.
    */
    public static function table() {
        return "job_analysis_setting";
    }

    /*!
      \brief	Returns the name of the database table in which all the Parameters
              for the Settings stored in the table specified in table()
      \see table()
    */
    public static function parameterTable() {
        return "job_analysis_parameter";
    }

} // End of class JobAnalysisSetting
