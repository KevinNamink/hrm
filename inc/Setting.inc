<?php
// This file is part of the Huygens Remote Manager
// Copyright and license notice: see license.txt

require_once ("Parameter.inc");
require_once ("Database.inc");
require_once ("User.inc");
require_once ("hrm_config.inc");

/*!
 \class    Setting
 \brief    (Abstract) base class for all specific Setting classes
 */
abstract class Setting {

  /*!
   \var		$parameter
   \brief	Array of Parameter object
   */
  protected $parameter;

  /*!
   \var	$message
   \brief	Message for last invalid Parameter check
   */
  protected $message;

  /*!
   \var	$owner
   \brief	The User or Owner of the Setting
   */
  protected $owner;

  /*!
   \var	$name
   \brief	The name of the Setting
   */
  protected $name;

  /*!
   \var	$isDefault
   \brief	If true, the Setting is the default
   */
  protected $isDefault;

  /*!
   \brief	Protected constructor: creates an empty Setting
   */
  protected function __construct() {
    $this->parameter = array ();
    $this->isDefault = False;
  }

  /*!
   \brief	Returns the Parameter of given name
   \param	$name	Name of the Parameter to return
   \return	a Parameter object or NULL if the Parameter does not exist
   */
  public function parameter($name) {
    if ( isset( $this->parameter[$name] ) ) {
      return $this->parameter[$name];
    } else {
      return NULL;
    }
  }

  /*!
   \brief	Sets a Parameter. The Parameter is stored in the Setting under its name.
   \param	$parameter	A Parameter.
   */
  public function set($parameter) {
    $this->parameter[$parameter->name()] = $parameter;
  }

  /*!
   \brief  Returns the (error) message generated by last Parameter check
   \return	(error) message
   */
  public function message() {
    return $this->message;
  }

  /*!
   \brief	Return all Parameter names
   \return	array of parameter names
   */
  public function parameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      $names[] = $parameter->name();
    }
    return $names;
  }

  /*!
   \brief	Returns the Owner of the Setting
   \return	Owner of the Setting
   */
  public function owner() {
    return $this->owner;
  }

  /*!
   \brief  Sets the Owner of the Setting
   \param  $owner	The owner of the Setting
   */
  public function setOwner( Owner $owner) {
    $this->owner = $owner;
  }

  /*!
   \brief	Returns the name of the Setting
   \return	name of the Setting
   */
  public function name() {
    return $this->name;
  }

  /*!
   \brief  Sets the name of the Setting
   \param  $name	Name of the Setting
   */
  public function setName($name) {
    $this->name = $name;
  }

  /*!
   \brief  Checks whether the Setting is the user's default setting
   \return	true if the Setting is the default Setting, false otherwise
   */
  public function isDefault() {
    return $this->isDefault;
  }

  /*!
   \brief  Sets current Setting as the default Setting for the user
   */
  public function beDefault() {
    $this->isDefault = True;
  }

  /*!
   \brief  Resets current Setting as no longer the default Setting for the user
   */
  public function resetDefault() {
    $this->isDefault = False;
  }

  /*!
   \brief  Copies the Parameter values from another Setting
   \param  $setting  The other Setting object from which the values are copied
   */
  public function copyParameterFrom($setting) {
    foreach ($setting->parameterNames() as $name) {
      $parameter = $this->parameter[$name];
      $otherParameter = $setting->parameter($name);
      $newValue = $otherParameter->internalValue();
      $parameter->setValue($newValue);
      $this->parameter[$name] = $parameter;
    }
  }

  /*!
   \brief	Returns the name of the database table in which the list of
   Setting names are stored.

   Besides the name, the table contains the Setting's name, owner and
   the standard (default) flag. This is an abstract function and must
   be reimplemented.
   */
  abstract function table();

  /*!
   \brief	Returns the name of the database table in which all the Parameters
   for the Settings stored in the table specified in table()

   This is an abstract function and must be reimplemented.
   \see table()
   */
  abstract function parameterTable();

  /*!
   \brief  Loads the Parameter values into current Setting
   \return	the loaded Setting
   */
  public function load() {
    $db = new DatabaseConnection();
    $result = $db->loadParameterSettings($this);
    if (!$result) {
      $this->message = "load setting - database access failed!";
    }
    return $result;
  }

  /*!
  	\brief  Saves all Parameter values from current Setting to the database
  	\return	true if saving was successul, false otherwise
   */
  public function save() {
    $db = new DatabaseConnection();
    $result = $db->saveParameterSettings($this);
    if (!$result) {
      $this->message = "save setting - database access failed!";
    }
    return $result;
  }

} // End of Setting class

/*
 ============================================================================
 */

/*!
 \class	ParameterSetting
 \brief	A ParameterSetting is a complete set of microscope, image and capture parameters
 */
class ParameterSetting extends Setting {

  /*!
   \brief	Constructor: constructs and initializes a ParameterSetting
   */
  public function __construct() {
    parent::__construct();
    $parameterClasses = array (
			'IsMultiChannel',
			'ImageFileFormat',
			'NumberOfChannels',
			'ImageGeometry',
			'MicroscopeType',
			'NumericalAperture',
			'ObjectiveMagnification',
			'ObjectiveType',
			'SampleMedium',
			'Binning',
			'ExcitationWavelength',
			'EmissionWavelength',
			'CMount',
			'TubeFactor',
			'CCDCaptorSize',
			'CCDCaptorSizeX',
			'ZStepSize',
			'TimeInterval',
			'PinholeSize',
			'PinholeSpacing',
			'PointSpreadFunction',
			'PSF',
			'CoverslipRelativePosition',
			'AberrationCorrectionNecessary',
			'PerformAberrationCorrection',
			'AberrationCorrectionMode',
			'AdvancedCorrectionOptions',
			'PSFGenerationDepth'
			);
			foreach ($parameterClasses as $class) {
			  $param = new $class;
			  $name = $param->name();
			  $this->parameter[$name] = $param;
			}
  }

  /*!
   \brief	Returns the name of the database table in which the list of
   Setting names are stored.

   Besides the name, the table contains the Setting's name, owner and
   the standard (default) flag.
   */
  public function table() {
    return "parameter_setting";
  }

  /*!
   \brief	Returns the name of the database table in which all the Parameters
   for the Settings stored in the table specified in table()
   \see table()
   */
  public function parameterTable() {
    return "parameter";
  }

  /*!
   \brief	Checks that the posted Image Parameters are all defined
   and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedImageParameters( $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    // Get the names of the relevant parameters
    $names = $this->imageParameterNames();

    // Check that the Parameters are set and contain valid values
    foreach ( $names as $name ) {
      if ( !isset( $postedParameters[ $name ] ) ||
      $postedParameters[ $name ] == '' ) {
        // The Parameter is not set or empty, return an informative error message
        switch ( $name ) {
          case "ImageFileFormat" :
            $this->message = "Please choose a file format!";
            break;
          case "ImageGeometry" :
            $this->message = "Please set the image geometry!";
            break;
          case "NumberOfChannels" :
            $this->message = "Please set the number of channels!";
            break;
          case "PointSpreadFunction" :
            $this->message = "Please indicate whether you " .
							"would like to calculate a theoretical PSF " .
							"or use an existing measured one!";
            break;
        }
        $noErrorsFound = False;
      } else {
        // The Parameter is set, now check the value
        $parameter = $this->parameter( $name );
        $parameter->setValue( $postedParameters[ $name ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    return $noErrorsFound;
  }


  /*!
   \brief	Checks that the posted Microscopy Parameters are all
   defined and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedMicroscopyParameters(  $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    // Get the names of the relevant parameters
    $names = $this->microscopeParameterNames();

    // Small correction to the multi-channel names
    $names[ array_search( 'ExcitationWavelength', $names ) ] = 'ExcitationWavelength0';
    $names[ array_search( 'EmissionWavelength', $names ) ] = 'EmissionWavelength0';

    // Check that the Parameters are set and contain valid values
    foreach ( $names as $name ) {
      if ( !isset( $postedParameters[ $name ] ) ||
      $postedParameters[ $name ] == '' ) {
        // The Parameter is not set or empty, return an informative error message
        switch ( $name ) {
          case "MicroscopeType" :
            $this->message = "Please set the microscope type!";
            break;
          case "NumericalAperture" :
            $this->message = "Please set the numerical aperture!";
            break;
          case "ObjectiveType" :
            $this->message = "Please set the objective type!";
            break;
          case "SampleMedium" :
            $this->message = "Please set the refractive index " .
						"of the sampling medium!";
            break;
          case "ExcitationWavelength0" :
            $this->message = "Please set the excitation wavelength!";
            break;
          case "EmissionWavelength0" :
            $this->message = "Please set the excitation wavelength!";
            break;
        }
        $noErrorsFound = False;
      } else {

        // Handle particular parameters
        if ( $name == 'ExcitationWavelength0' ) {
          $value = array( null, null, null, null, null );
          $value[ 0 ] = $postedParameters[ $name ];
          for ( $i = 1; $i < 5; $i++ ) {
            if ( isset( $postedParameters[ "ExcitationWavelength$i" ] ) ) {
              $value[ $i ] = $postedParameters[ "ExcitationWavelength$i" ];
            }
          }
          $name = 'ExcitationWavelength';
        } elseif ( $name == 'EmissionWavelength0' ) {
          $value = array( null, null, null, null, null );
          $value[ 0 ] = $postedParameters[ $name ];
          for ( $i = 1; $i < 5; $i++ ) {
            if ( isset( $postedParameters[ "EmissionWavelength$i" ] ) ) {
              $value[ $i ] = $postedParameters[ "EmissionWavelength$i" ];
            }
          }
          $name = 'EmissionWavelength';
        } elseif ( $name == "SampleMedium" &&
        $postedParameters[$name] == "custom" ) {
          if (isset($postedParameters[ 'SampleMediumCustomValue' ] ) ) {
            $value = $postedParameters[ 'SampleMediumCustomValue'];
          }
        } else {
          $value = $postedParameters[ $name ];
        }

        // Set the Parameter and check the value
        $parameter = $this->parameter( $name );
        $parameter->setValue( $value );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    return $noErrorsFound;
  }

  /*!
   \brief	Checks that the posted Capturing Parameters are all defined
   and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedCapturingParameters( $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    // CCDCaptorSizeX must always be defined
    if ( !isset( $postedParameters[ "CCDCaptorSizeX" ] ) ||
    ( $postedParameters[ "CCDCaptorSizeX" ] == '' ) ) {
      $this->message = "Please set the pixel size!";
      $noErrorsFound = False;
    } else {
      // Set the Parameter and check the value
      $parameter = $this->parameter( "CCDCaptorSizeX" );
      $parameter->setValue( $postedParameters[ "CCDCaptorSizeX" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    // ZStepSize must be defined for all 3D geometries
    if ( $this->isThreeDimensional( ) ) {
      if ( ( !isset( $postedParameters[ "ZStepSize" ] ) ) ||
      ( $postedParameters[ "ZStepSize" ] == '' ) ) {
        $this->message = "Please set the z-step!";
        $noErrorsFound = False;
      } else {
        // Set the Parameter and check the value
        $parameter = $this->parameter( "ZStepSize" );
        $parameter->setValue( $postedParameters[ "ZStepSize" ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    // TimeInterval must be defined for the XY-time and XYZ-time geometry
    if ( $this->isTimeSeries( ) ) {
      if ( !isset( $postedParameters[ "TimeInterval" ] ) ||
      ( $postedParameters[ "TimeInterval" ] == '' ) ) {
        $this->message = "Please set the time interval!";
        $noErrorsFound = False;
      } else {
        // Set the Parameter and check the value
        $parameter = $this->parameter( "TimeInterval" );
        $parameter->setValue( $postedParameters[ "TimeInterval" ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    // PinholeSize must be defined for all confocal microscopes
    if ( $this->isMultiPointOrSinglePointConfocal( ) ) {
      if ( ( !isset( $postedParameters[ "PinholeSize0" ] ) ) ||
      ( $postedParameters[ "PinholeSize0" ] == '' ) ) {
        $this->message = "Please set the pinhole size!";
        $noErrorsFound = False;
      } else {
        // Set the Parameter and check the value
        $value = array( null, null, null, null, null );
        $value[ 0 ] = $postedParameters[ "PinholeSize0" ];
        for ( $i = 1; $i < 5; $i++ ) {
          if ( isset( $postedParameters[ "PinholeSize$i" ] ) ) {
            $value[ $i ] = $postedParameters[ "PinholeSize$i" ];
          }
        }
        $parameter = $this->parameter( "PinholeSize" );
        $parameter->setValue( $value );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    // PinholeSpacing must be defined for spinning disk
    if ( $this->isNipkowDisk() ) {
      if ( ( !isset( $postedParameters[ "PinholeSpacing" ] ) ) ||
      ( $postedParameters[ "PinholeSpacing" ] == '' ) ) {
        $this->message = "Please set the pinhole spacing!";
        $noErrorsFound = False;
      } else {
        // Set the Parameter and check the value
        $parameter = $this->parameter( "PinholeSpacing" );
        $parameter->setValue( $postedParameters[ "PinholeSpacing" ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    return $noErrorsFound;

  }

  /*!
   \brief	Checks that the posted Aberration Correction Parameters are all defined
   and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedAberrationCorrectionParameters( $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    // The following parameters are always defined

    if ( !isset( $postedParameters[ "PerformAberrationCorrection" ] ) ) {
      $this->message = "Please choose whether to perform the correction!";
      $noErrorsFound = False;
    } else {
      // Set the Parameter and check the value
      $parameter = $this->parameter( "PerformAberrationCorrection" );
      $parameter->setValue( $postedParameters[ "PerformAberrationCorrection" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    if ( !isset( $postedParameters[ "CoverslipRelativePosition" ] ) ) {
      $this->message = "Please choose the relative coverslip position!";
      $noErrorsFound = False;
    } else {
      // Set the Parameter and check the value
      $parameter = $this->parameter( "CoverslipRelativePosition" );
      $parameter->setValue( $postedParameters[ "CoverslipRelativePosition" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    if ( !isset( $postedParameters[ "AberrationCorrectionMode" ] ) ) {
      $this->message = "Please set the aberration correction mode!";
      $noErrorsFound = False;
    } else {
      // Set the Parameter and check the value
      $parameter = $this->parameter( "AberrationCorrectionMode" );
      $parameter->setValue( $postedParameters[ "AberrationCorrectionMode" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    if ( !isset( $postedParameters[ "AdvancedCorrectionOptions" ] ) ) {
      $this->message = "Please indicate the options for the advanced correction!";
      $noErrorsFound = False;
    } else {
      // Set the Parameter and check the value
      $parameter = $this->parameter( "AdvancedCorrectionOptions" );
      $parameter->setValue( $postedParameters[ "AdvancedCorrectionOptions" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    // The following Parameters may be defined depending on the values of
    // the previous one, but we will check them only if no errors have been
    // found so far
    if ( $noErrorsFound == False ) {
      return $noErrorsFound;
    }

    $parameter = $this->parameter( "PerformAberrationCorrection" );
    $perform   = $parameter->value();
    $parameter = $this->parameter( "AberrationCorrectionMode" );
    $mode      = $parameter->value();
    if ( $perform == 1 && $mode == "advanced" ) {
      if ( !isset( $postedParameters[ "PSFGenerationDepth" ] ) ) {
        $this->message = "Please indicate the depth for PSF generation!";
        $noErrorsFound = False;
      } else {
        // Set the Parameter and check the value
        $parameter = $this->parameter( "PSFGenerationDepth" );
        $parameter->setValue( $postedParameters[ "PSFGenerationDepth" ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }
    return $noErrorsFound;
  }

  /*!
   \brief	Checks that the posted Calculate Pixel Size Parameters are all defined
   and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedCalculatePixelSizeParameters( $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    $names = $this->pixelSizeCalculationParameterNames();

    // Check that the Parameters are set and contain valid values
    foreach ( $names as $name ) {
      if ( !isset( $postedParameters[ $name ] ) ||
      $postedParameters[ $name ] == '' ) {
        // The Parameter is not set or empty, return an informative error message
        switch ( $name ) {
          case "CCDCaptorSize" :
            $this->message = "Please set the CCD pixel size!";
            break;
          case "Binning" :
            $this->message = "Please set the binning!";
            break;
          case "NumberOfChannels" :
            $this->message = "Please set CMount!";
            break;
          case "TubeFactor" :
            $this->message = "Please set the tube factore!";
            break;
          case "ObjectiveMagnification" :
            $this->message = "Please set the objective magnification!";
            break;
        }
        $noErrorsFound = False;
      } else {
        // The Parameter is set, now check the value
        $parameter = $this->parameter( $name );
        $parameter->setValue( $postedParameters[ $name ] );
        $this->set( $parameter );
        if( !$parameter->check() ) {
          $this->message = $parameter->message();
          $noErrorsFound = False;
        }
      }
    }

    return $noErrorsFound;

  }

  /*!
   \brief	Returns the Parameter values needed for the aberration correction
   \return array with all Parameter values for the aberration correction. The keys are the Parameter names
   */
  public function getAberractionCorrectionParameters() {
    $parameters = array(
			'AberrationCorrectionNecessary' => $this->parameter('AberrationCorrectionNecessary')->value(),
			'PerformAberrationCorrection' => $this->parameter('PerformAberrationCorrection')->value(),
			'CoverslipRelativePosition' => $this->parameter('CoverslipRelativePosition')->value(),
			'AberrationCorrectionMode' => $this->parameter('AberrationCorrectionMode')->value(),
			'AdvancedCorrectionOptions'=>$this->parameter('AdvancedCorrectionOptions')->value(),
			'PSFGenerationDepth'=> $this->parameter('PSFGenerationDepth')->value() );
    return $parameters;
  }

  /*!
   \brief	Returns all Image Parameter names
   \return array of Image Parameter names
   */
  public function imageParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isForImage()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief	Returns all Microscope Parameter names
   \return array of Microscope Parameter names
   */
  public function microscopeParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isForMicroscope()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief	Returns all Capture Parameter names
   \return array of Capture Parameter names
   */
  public function capturingParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isForCapture()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief	Returns all Correction Parameter names
   \return array of Correction Parameter names
   */
  public function correctionParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isForCorrection()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief	Returns all Correction Parameter names
   \return array of Correction Parameter names
   */
  public function pixelSizeCalculationParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isForPixelSizeCalculation()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief  Displays the setting as a text containing Parameter names and their values
   \todo	Refactor this!
   */
  public function displayString() {
    $result = '';

    // These parameters are important to properly display all the others
    $numberOfChannels = $this->parameter( "NumberOfChannels" )->value( );
    $PSF = $this->parameter( "PointSpreadFunction" )->value( );
    $performAberrationCorrection = $this->parameter( "PerformAberrationCorrection" )->value( );
    $aberrationCorrectionMode = $this->parameter( "AberrationCorrectionMode" )->value( );
    $advancedCorrectionOptions = $this->parameter( "AdvancedCorrectionOptions" )->value( );

    // The relevant parameters for theoretical vs. measured PSF are
    // displayed, making sure that the number of entries (e.g. for the
    // wavelengths) reflect the user-defined number of channels
    foreach ($this->parameter as $parameter) {
      if ($this->isFixedGeometryFormat() && $parameter->name() == 'ImageGeometry')
      continue;
      if (!$this->isMultiPointOrSinglePointConfocal() && $parameter->name() == 'PinholeSize')
      continue;
      if (!$this->isMultiChannel() && $parameter->name() == 'NumberOfChannels')
      continue;
      if (!$this->isThreeDimensional() && $parameter->name() == 'ZStepSize')
      continue;
      if ($parameter->name() == 'IsMultiChannel' || $parameter->name() == 'PSF')
      continue;
      if ( ( $parameter->name() == 'ExcitationWavelength' || $parameter->name() == 'EmissionWavelength' ) && $PSF == 'measured' )
      continue;
      if ($parameter->name() == 'SampleMedium' && $PSF == 'measured' )
      continue;
      if ($parameter->name() == 'CMount' ) // This is obsolete
      continue;
      if ($parameter->name() == 'TubeFactor' ) // This is obsolete
      continue;
      if ($parameter->name() == 'CCDCaptorSizeX' && $PSF == 'measured' )
      continue;
      if ($parameter->name() == 'CoverslipRelativePosition' && $PSF == 'measured' )
      continue;
      if ($parameter->name() == 'CoverslipRelativePosition' && $performAberrationCorrection == 0 )
      continue;
      if ($parameter->name() == 'AberrationCorrectionMode' && $performAberrationCorrection == 0 )
      continue;
      if ($parameter->name() == 'AdvancedCorrectionOptions' && !( $performAberrationCorrection == 1 && $aberrationCorrectionMode == 'advanced' ) )
      continue;
      if ($parameter->name() == 'PSFGenerationDepth' && !( $performAberrationCorrection == 1 && $aberrationCorrectionMode == 'advanced' && $advancedCorrectionOptions == 'user' ) )
      continue;
      $result = $result . $parameter->displayString( $numberOfChannels );
    }
    return $result;
  }

  /*!
   \brief	Asks HuCore to calculate the ideal (Nyquist) sampling rate
   for the current conditions.
   \return	an array with the ideal XY and Z sampling
   */
  public function calculateNyquistRate() {
    // Use the most restrictive wavelength to compute the adaption
    $parameter = $this->parameter('EmissionWavelength');
    if ( $this->isTwoPhoton()
    || $this->isMultiPointOrSinglePointConfocal()) {
      $parameter = $this->parameter('ExcitationWavelength');
    }
    $value = $parameter->value();
    $mostRestrictiveChannel = 0;
    $mostRestrictiveWavelength = $value[0];
    for ($i = 1; $i < $this->numberOfChannels(); $i++) {
      if ($value[$i] < $mostRestrictiveWavelength) {
        $mostRestrictiveChannel = $i;
        $mostRestrictiveWavelength = $value[$i];
      }
    }
    $parameter = $this->parameter('EmissionWavelength');
    $value = $parameter->value();
    $em = $value[$mostRestrictiveChannel];
    $parameter = $this->parameter('ExcitationWavelength');
    $value = $parameter->value();
    $ex = $value[$mostRestrictiveChannel];

    $parameter = $this->parameter('NumericalAperture');
    $na = (float) $parameter->value();

    $parameter = $this->parameter('MicroscopeType');
    $micr = $parameter->translatedValue();

    $parameter = $this->parameter('ObjectiveType');
    $ril = $parameter->translatedValue();

    if ($this->isTwoPhoton()) {
      $pcnt = 2;
    } else {
      $pcnt = 1;
    }
    // Only micr, na, em, ex and pcnt are necessary to calculate it.

    $opt = "-micr $micr -na $na -em $em -ex $ex -pcnt $pcnt -ril $ril";
    $ideal = askHuCore ("calculateNyquistRate", $opt);
    // print_r($ideal);
    return array( $ideal['xy'], $ideal['z'] );
  }


  /*!
   \brief	Checks whether the chosen file format is multi channel
   \todo 	This is currently UNUSED!
   \return	true if multi channel, false otherwise
   */
  public function checkMultiChannelImageParameter() {
    $result = True;
    $parameter = $this->parameter('ImageFileFormat');
    $fileFormat = $parameter->value();
    if ((!in_array($fileFormat, $this->multiChannelFileFormats()))) {
      $this->message = "Please select a multichannel file format (" . implode(", ", $this->multiChannelFileFormats()) . ")!";
      return False;
    }
    if (!in_array($fileFormat, $this->fixedGeometryFileFormats())) {
      $result = $this->checkGeometry('multi');
    }
    /*
     if (in_array($fileFormat, $this->variableChannelFileFormats())) {
     $result = $this->checkNumberOfChannels() && $result;
     }
     */
    return $result;
  }

  /*!
   \brief	Checks the Image Geometry (two or three dimensional, time series or single image).
   \param	$prefix	Either 'single' (for single-channel geometries) or 'multi' (for multi-channel geometries)
   \todo	This is currently UNUSED!
   \return	true if the geometry is valid, false otherwise
   */
  public function checkGeometry($prefix) {
    $result = True;
    $parameter = $this->parameter('ImageGeometry');
    $geometry = $parameter->internalValue();
    if ($geometry == '') {
      $geometry = '_';
    }
    $parts = explode('_', $geometry);
    $geometry = $parts[1];
    $prefix_ok = True;
    if ($prefix != $parts[0]) {
      $prefix_ok = False;
    }
    if (!$parameter->check() || !$prefix_ok) {
      $this->message = "Please select the image kind (" . implode(", ", $parameter->possibleValues()) . ")!";
      return False;
    }
    return $result;
  }

  /*!
   \brief	Returns all 3-D geometries (i.e. 'XYZ', 'XYZ - time')
   \return	the 3D geometries
   */
  public function threeDimensionalGeometries() {
    static $threeDimensionalGeometries;
    if ($threeDimensionalGeometries == NULL) {
      $db = new DatabaseConnection();
      $threeDimensionalGeometries = $db->geometriesWith(True, NULL);
    }
    return $threeDimensionalGeometries;
  }

  /*!
   \brief	Returns all time series geometries (i.e. 'XY - time', 'XYZ - time')
   \return	the time series geometries
   */
  public function timeSeriesGeometries() {
    static $timeSeriesGeometries;
    if ($timeSeriesGeometries == NULL) {
      $db = new DatabaseConnection();
      $timeSeriesGeometries = $db->geometriesWith(NULL, True);
    }
    return $timeSeriesGeometries;
  }

  /*!
   \brief	Returns all fixed geometry file formats (i.e. those that are 2D)
   \return	the fixed geometry file formats
   */
  public function fixedGeometryFileFormats() {
    static $fixedGeometryFileFormats;
    if ($fixedGeometryFileFormats == NULL) {
      $db = new DatabaseConnection();
      $fixedGeometryFileFormats = $db->fileFormatsWith(NULL, NULL, True);
    }
    return $fixedGeometryFileFormats;
  }

  /*!
   \brief	Checks whether currently chosen file format has fixed geometry
   \return	true if the chosen file format has fixed geometry, false otherwise
   */
  public function isFixedGeometryFormat() {
    $param = $this->parameter('ImageFileFormat');
    $result = in_array($param->value(), $this->fixedGeometryFileFormats());
    return $result;
  }

  /*!
   \brief	Returns the file formats that support single channel images
   \todo	This function DOES NOT BELONG in the Setting class!
   \return	array of file formats
   */
  public function singleChannelFileFormats() {
    static $singleChannelFileFormats;
    if ($singleChannelFileFormats == NULL) {
      $db = new DatabaseConnection();
      $singleChannelFileFormats = $db->fileFormatsWith(True, NULL, NULL);
    }
    return $singleChannelFileFormats;
  }

  /*!
   \brief	Returns the file formats that support multi-channel images
   \todo	This function DOES NOT BELONG in the Setting class!
   \return	array of file formats
   */
  public function multiChannelFileFormats() {
    static $multiChannelFileFormats;
    if ($multiChannelFileFormats == NULL) {
      $db = new DatabaseConnection();
      $multiChannelFileFormats = $db->fileFormatsWith(False, NULL, NULL);
    }
    return $multiChannelFileFormats;
  }

  /*!
   \brief	Returns the file formats that support a variable number of channels per file
   \todo	This function DOES NOT BELONG in the Setting class!
   \return	array of file formats
   */
  public function variableChannelFileFormats() {
    static $variableChannelFileFormats;
    if ($variableChannelFileFormats == NULL) {
      $db = new DatabaseConnection();
      $variableChannelFileFormats = $db->fileFormatsWith(NULL, True, NULL);
    }
    return $variableChannelFileFormats;
  }

  /*!
   \brief	Checks whether current Setting is for multi-channel file formats
   \return	true if the number of channels set for current Setting is > 1, false otherwise
   */
  public function isMultiChannel() {
    $parameter = $this->parameter('NumberOfChannels');
    $num_channels = (int) $parameter->value();
    if ($num_channels > 1) {
      $result = True;
    } else {
      $result = False;
    }
    return $result;
  }

  /*!
   \brief	Checks whether currently selected file format is variable channel
   \return	true if the currently selected file format is variable channel
   \see variableChannelFileFormats()
   */
  function isVariableChannelFormat() {
    $result = False;
    $parameter = $this->parameter('ImageFileFormat');
    if (in_array($parameter->value(), $this->variableChannelFileFormats())) {
      $result = True;
    }
    return $result;
  }

  /*!
   \brief	Checks whether currently selected file format is one of the TIFF variants
   \return	true if the currently selected file format is a TIFF variant
   */
  public function isTif() {
    $result = False;
    $parameter = $this->parameter('ImageFileFormat');
    if (strstr($parameter->value(), 'tif'))
    $result = True;
    return $result;
  }

  /*
   \brief	Returns the number of channels of the Setting
   \return	the number of channels
   */
  public function numberOfChannels() {
    $parameter = $this->parameter('NumberOfChannels');
    if ( $parameter ) {
      return ( (int) $parameter->value() );
    } else {
      return ( (int) 1 );
    }
  }

  /*!
   \brief	Checks whether the currently selected microscope type is spinning (Nipkow) disk confocal
   \return	true if the currently selected microscope type is spinning (Nipkow) disk, false otherwise
   */
  public function isNipkowDisk() {
    return $this->isMultiPointConfocal();
  }

  /*!
   \brief	Checks whether the currently selected microscope type is 2-Photon
   \return	true if the currently selected microscope type is 2-Photon, false otherwise
   */
  public function isTwoPhoton() {
    $parameter = $this->parameter('MicroscopeType');
    $value = $parameter->value();
    return ($value == 'two photon');
  }

  /*!
   \brief	Checks whether the currently selected microscope type is single-point confocal
   \return	true if the currently selected microscope type is single-point confocal, false otherwise
   */
  public function isSinglePointConfocal() {
    $parameter = $this->parameter('MicroscopeType');
    $value = $parameter->value();
    return ($value == 'single point confocal');
  }

  /*!
   \brief	Checks whether the currently selected microscope type is spinning (Nipkow) disk confocal
   \return	true if the currently selected microscope type is spinning (Nipkow) disk, false otherwise
   */
  public function isMultiPointConfocal() {
    $parameter = $this->parameter('MicroscopeType');
    $value = $parameter->value();
    return ($value == 'multipoint confocal (spinning disk)');
  }

  /*!
   \brief	Checks whether the currently selected microscope type is widefield
   \return	true if the currently selected microscope type is widefield, false otherwise
   */
  public function isWidefield() {
    $parameter = $this->parameter('MicroscopeType');
    $value = $parameter->value();
    return ($value == 'widefield');
  }

  /*!
   \brief	Checks whether the currently selected microscope type is either widefield of spinning disk
   \return	true if the currently selected microscope type is either widefield of spinning disk, false otherwise
   */
  public function isWidefieldOrMultiPoint() {
    return ($this->isWidefield() || $this->isMultiPointConfocal());
  }

  /*!
   \brief	Checks whether the currently selected microscope type is either 2-Photon or single-point confocal
   \todo 	This function is currently not in use!
   \return	true if the currently selected microscope type is either 2-Photon or single-point confocal, false otherwise
   */
  public function isTwoPhotonOrSinglePoint() {
    return ($this->isSinglePointConfocal() || $this->isTwoPhoton());
  }

  /*!
   \brief	Checks whether the currently selected microscope type is any type of confocal
   \return	true if the currently selected microscope type is any type of confocal, false otherwise
   */
  public function isMultiPointOrSinglePointConfocal() {
    return ($this->isSinglePointConfocal() || $this->isMultiPointConfocal());
  }

  /*!
   \brief	Checks that this Setting is for a 3D geometry and file format
   \return	true if both selected geometry and file format are 3D, false otherwise
   */
  public function isThreeDimensional() {
    $parameter = $this->parameter('ImageGeometry');
    $value = $parameter->value();
    $format = $this->parameter('ImageFileFormat');
    $formatValue = $format->value();
    return (in_array($value, $this->threeDimensionalGeometries()) && !in_array($formatValue, $this->fixedGeometryFileFormats()));
  }

  /*!
   \brief	Checks that this Setting is for a time series of images
   \return	true if both selected geometry and file format are for time series, false otherwise
   */
  public function isTimeSeries() {
    if ($this->isFixedGeometryFormat())
    return False;
    $parameter = $this->parameter('ImageGeometry');
    $value = $parameter->value();
    return (in_array($value, $this->timeSeriesGeometries()));
  }

  /*!
   \brief	Returns the pixel size (the value of CCDCaptorSizeX) in nm
   \todo	This is redundant!
   \return	pixel size in nm
   */
  public function pixelSize() {
    $param = $this->parameter('CCDCaptorSizeX');
    $size = (float) $param->value();
    return $size;
  }

  /*!
   \brief	Returns the sample size in X direction in um
    
   This is simply pixelSize() / 1000.
    
   \return	sample size in um
   */
  public function sampleSizeX() {
    $size = $this->pixelSize();
    return $size / 1000;
  }

  /*!
   \brief	Returns the sample size in Y direction in um
    
   This just returns the value in X direction.
   \return	sample size in um
   */
  public function sampleSizeY() {
    return $this->sampleSizeX();
  }

  /*!
   \brief	Returns the sample size in um in Z direction
    
   This is the value of the z-step size / 1000.

   \return	sample size in um
   */
  public function sampleSizeZ() {
    $param = $this->parameter('ZStepSize');
    $size = (float) $param->value();
    return $size / 1000;
  }

  /*!
   \brief	Returns the time interval between consecutive time points in a time series in seconds
   \return	time interval in seconds
   */
  public function sampleSizeT() {
    $param = $this->parameter('TimeInterval');
    $size = (float) $param->value();
    return $size / 1;
  }

  /*!
   \brief	This always returns 1!
    
   \todo Adaptation no longer exists in the HRM. But this functionality could be used to address the
   different scaling factors between channels intoduced by histogram stretching for non SVI file formats
   \return	1.
   */
  public function sampleSizeAdaptionFactor() {
    $result = ( floatval(1) );
    return $result;
  }

  /*!
   \brief	Returns the ideal axial sample size for chosen channel
   \todo 	This should be removed
   \param	$channel	Channel number
   \return	the ideal axial sample size for the chosen channel
   */
  public function idealSampleSizeZFor($channel) {
    if ($this->isWidefield()) {
      $parameter = $this->parameter('EmissionWavelength');
      $value = $parameter->value();
      $lambda = $value[$channel];
      $factor = 2;
    } else {
      $parameter = $this->parameter('ExcitationWavelength');
      $value = $parameter->value();
      $lambda = $value[$channel];
      $factor = 4;
    }
    $parameter = $this->parameter('ObjectiveType');
    $rim = (float) $parameter->translatedValue();
    // TODO check if NA should be adapted in case of widefield and two-photon
    $parameter = $this->parameter('NumericalAperture');
    $na = (float) $parameter->value();
    $deltaZ = $lambda / ($factor * $rim * (1 - cos(asin($na / $rim))));
    return $deltaZ;
  }
}

/*!
 \class	TaskSetting
 \brief	A TaskSetting is a complete set of restoration parameters
 */
class TaskSetting extends Setting {

  /*!
   \var	$numberOfChannels
   \brief	Number of channels for the parameters of the TaskSetting
   */
  protected $numberOfChannels;

  /*!
   \brief	Constructor: constructs and initializes a TaskSetting
   */
  public function TaskSetting() {
    parent::__construct();
    $parameterClasses = array (
			'SignalNoiseRatio',
			'BackgroundOffsetPercent', 
			'NumberOfIterations',
			'OutputFileFormat',
			'MultiChannelOutput',
			'QualityChangeStoppingCriterion',
			'DeconvolutionAlgorithm'
			);
			foreach ($parameterClasses as $class) {
			  $param = new $class;
			  $name = $param->name();
			  $this->parameter[$name] = $param;
			  $this->numberOfChannels = NULL;
			}
  }

  /*!
   \brief	Returns the name of the database table in which the list of
   Setting names are stored.

   Besides the name, the table contains the Setting's name, owner and
   the standard (default) flag. This is an abstract function and must
   be reimplemented.
   */
  public function table() {
    return "task_setting";
  }

  /*!
   \brief	Returns the name of the database table in which all the Parameters
   for the Settings stored in the table specified in table()

   This is an abstract function and must be reimplemented.
   \see table()
   */
  public function parameterTable() {
    return "task_parameter";
  }

  /*!
   \brief	Checks that the posted Task Parameters are all defined
   and valid
   \param	$postedParameters	The $_POST array
   */
  public function checkPostedTaskParameters( $postedParameters ) {

    if ( count( $postedParameters ) == 0 ) {
      $this->message = '';
      return False;
    }

    $this->message = '';
    $noErrorsFound = True;

    // Get the names of the relevant parameters
    $names = $this->taskParameterNames();

    // Deconvolution Algorithm - this should always be defined, but since
    // other parameters depend on it, in case it is not defined we return
    // here
    if ( !isset( $postedParameters[ "DeconvolutionAlgorithm" ] ) ) {
      $this->message = 'Please choose a deconvolution algorithm!';
      return False;
    }

    // Set the Parameter and check the value
    $parameter = $this->parameter( "DeconvolutionAlgorithm" );
    $parameter->setValue( $postedParameters[ "DeconvolutionAlgorithm" ] );
    $this->set( $parameter );
    if( !$parameter->check() ) {
      $this->message = 'Unknown deconvolution algorithm!';
      return False;
    }
    $algorithm = strtoupper( $parameter->value() );

    // Signal-To-Noise Ratio
    // Depending on the choice of the deconvolution algorithm, we will
    // check only the relevant entries
    $value = array( null, null, null, null, null );
    for ( $i = 0; $i < 5; $i++ ) {
      $name = "SignalNoiseRatio" . $algorithm . "$i";
      if ( isset( $postedParameters[ $name ] ) ) {
        $value[ $i ] = $postedParameters[ $name ];
      }
    }
    $parameter = $this->parameter( "SignalNoiseRatio" );
    $parameter->setValue( $value );
    $this->set( $parameter );
    if( !$parameter->check() ) {
      $this->message = $parameter->message();
      $noErrorsFound = False;
    }

    // Background estimation
    if ( !isset( $postedParameters[ "BackgroundEstimationMode" ] ) ||
    $postedParameters[ "BackgroundEstimationMode" ] == '' ) {
      $this->message = 'Please choose a background estimation mode!';
      $noErrorsFound = False;
    } else {
      $value = array( null, null, null, null, null );
      switch ( $postedParameters[ "BackgroundEstimationMode" ] ) {
        case 'auto':

          $value[ 0 ] = 'auto';
          break;

        case 'object' :

          $value[ 0 ] = 'object';
          break;

        case 'manual' :
           
          for ( $i = 0; $i < 5; $i++ ) {
            $name = "BackgroundOffsetPercent$i";
            if ( isset( $postedParameters[ $name ] ) ) {
              $value[ $i ] = $postedParameters[ $name ];
            }
          }
          break;

        default :
          $this->message = 'Unknown background estimation mode!';
          $noErrorsFound = False;
      }
      $parameter = $this->parameter( "BackgroundOffsetPercent" );
      $parameter->setValue( $value );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }

    }

    // Number of iterations
    if ( isset( $postedParameters[ "NumberOfIterations" ] ) ||
    $postedParameters[ "NumberOfIterations" ] == '' ) {
      $parameter = $this->parameter( "NumberOfIterations" );
      $parameter->setValue( $postedParameters[ "NumberOfIterations" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    // Quality change
    if ( isset( $postedParameters[ "QualityChangeStoppingCriterion" ] ) ||
    $postedParameters[ "QualityChangeStoppingCriterion" ] == '' ) {
      $parameter = $this->parameter( "QualityChangeStoppingCriterion" );
      $parameter->setValue( $postedParameters[ "QualityChangeStoppingCriterion" ] );
      $this->set( $parameter );
      if( !$parameter->check() ) {
        $this->message = $parameter->message();
        $noErrorsFound = False;
      }
    }

    return $noErrorsFound;
  }

  /*!
   \brief	Returns all Task Parameter names
   \return array of Task Parameter names
   */
  public function taskParameterNames() {
    $names = array ();
    foreach ($this->parameter as $parameter) {
      if ($parameter->isTaskParameter()) {
        $names[] = $parameter->name();
      }
    }
    return $names;
  }

  /*!
   \brief	Checks whether the chosen file format is Imaris classic
   \return	true if the selectedoutput file format is Imaris classic, false otherwise
   */
  public function isOutputIms() {
    $result = False;
    $parameter = $this->parameter('OutputFileFormat');
    if (strstr($parameter->value(), 'ims'))
    $result = True;
    return $result;
  }

  /*!
   \brief	Always returns false
   \todo	Get rid of this function as soon as the new template-based jobs are implemented!
   \return	false
   */
  public function isStepProcessing() {
    return false;
    //    $parameter = $this->parameter('StyleOfProcessing');
    //    return ($parameter->value() == 'step' || $parameter->value() == 'step combined');
  }

  /*!
   \brief	Always returns false
   \todo	Get rid of this function as soon as the new template-based jobs are implemented!
   \return	false
   */
  public function isStepCombinedProcessing() {
    return false;
    // TODO This is obsolete code that should be removed!!

    //$parameter = $this->parameter('StyleOfProcessing');
    //return $parameter->value() == 'step combined';
  }

  /*!
   \brief	Sets the number of channels for the Setting
   
   The number of channels of a TaskSetting must match the number 
   of channels of the ParameterSetting it couples with. All variable
   channels Parameter onjects in the TaskSetting will updated.
   
   \param	$channels	Number of channels (between 1 and 5)
   */  
  public function setNumberOfChannels($channels) {
    $this->numberOfChannels = $channels;
    foreach ($this->parameter as $parameter) {
      if ($parameter->isVariableChannel()) {
        $parameter->setNumberOfChannels($this->numberOfChannels);
        $this->set($parameter);
      }
    }
  }

  /*!
   \brief	Returns the number of channels of the Setting
   \return	the number of channels for the Setting 
   */  
  public function numberOfChannels() {
    return $this->numberOfChannels;
  }

  /*!
   \brief  Displays the setting as a text containing Parameter names and their values
   \param	$numberOfChannels Number of channels (optional, default value is 0)
   \todo	Remove the $numberOfChannels requirement
   */
  public function displayString( $numberOfChannels = 0 ) {	// return the string that will be attach to the success notification message
    $result = '';
    $algorithm = $this->parameter('DeconvolutionAlgorithm')->value();
    foreach ($this->parameter as $parameter) {
		if ($parameter->name() == 'SignalNoiseRatio') {
			$parameter->setAlgorithm( $algorithm );
		}
	  $result = $result . $parameter->displayString( $this->numberOfChannels() );
    }
    return $result;
  }

  /*!
   \brief	Prints (!) the TaskSetting as a text containing all parameters
			and their values. Only the parameter OutputFileFormat is left out.
			This is used for the web display where the output file format has
			not been choosen yet.
   \param	$numberOfChannels Number of channels (optional, default value is 0)
   \todo	Refactor!
   */
  public function displayWithoutOutputFileFormat( $numberOfChannels = 0 ) {
    print $this->displayStringWithoutOutputFileFormat( $numberOfChannels );
  }

  /*!
   \brief	Returns the TaskSetting as a text containing all parameters
			and their values. Only the parameter OutputFileFormat is left out.
			This is used for the web display where the output file format has
			not been choosen yet.
   \param	$numberOfChannels Number of channels (optional, default value is 0)
   \todo	Refactor!
   */
  public function displayStringWithoutOutputFileFormat( $numberOfChannels = 0 ) {
    $parameter = $this->parameter('OutputFileFormat');
    $parameterList = $this->parameter;
    unset ($parameterList['OutputFileFormat']);
    $this->parameter = $parameterList;
    $result = $this->displayString( $numberOfChannels );
    $parameterList['OutputFileFormat'] = $parameter;
    $this->parameter = $parameterList;
    return $result;
  }

} // End of class taskSetting

//!---------------------------------------------------------
// \class    JobParameterSetting
// \brief     A parameter setting is a complete set of
//           microscope, image and capture parameters. A job
//           parameter setting is a parameter setting that
//           is used when a job is executed by the queue
//           manager. It uses different database tables and
//           knows how to put its parameter settings onto a
//           script.
//!---------------------------------------------------------
class JobParameterSetting extends ParameterSetting {
  //!---------------------------------------------------------
  // @function    JobParameterSetting::table()
  // \brief        Answer the name of the database table in
  //              which the job parameter settings are stored. The
  //              table contains the setting's name the owner
  //              and the standard (default) flag.
  // \return      String
  //!---------------------------------------------------------
  function table() {
    return "job_parameter_setting";
  }
  //!---------------------------------------------------------
  // @function    JobParameterSetting::parameterTable()
  // \brief        Answer the name of the database table in
  //              which the parameters for settings of the
  //              receiver's kind are stored.
  // \return      String
  //!---------------------------------------------------------
  function parameterTable() {
    return "job_parameter";
  }

  function putScriptOn($script) {
    $newScript = $script;
    $newScript = $newScript . '$imageName setp ';
    $newScript = $newScript . $this->microscopeParameterString();
    $newScript = $newScript . $this->microscopeTypeString();
    $newScript = $newScript . $this->numericalApertureString();
    $newScript = $newScript . $this->lensRefractiveIndexString();
    $newScript = $newScript . $this->mediumRefractiveIndexString();
    // Support for Nipkow spinning disk
    if ($this->isNipkowDisk()) {
      $newScript = $newScript . $this->pinholeSpacingString();
    }
    $newScript = $newScript . $this->photonCountString();
    $newScript = $newScript . "\n";
    $newScript = $newScript . $this->excitationWavelengthsString();
    $newScript = $newScript . $this->emissionWavelengthsString();
    if ($this->isMultiPointOrSinglePointConfocal()) {
      $newScript = $newScript . $this->pinholeRadiusString();
    }
    return $newScript;
  }

  function excitationWavelengthsString() {
    $result = $this->multiChannelParameterString('ExcitationWavelength', 'ex');
    return $result;
  }

  function emissionWavelengthsString() {
    $result = $this->multiChannelParameterString('EmissionWavelength', 'em');
    return $result;
  }

  function multiChannelParameterString($name, $command) {
    $parameter = $this->parameter($name);
    $values = $parameter->value();
    $result = "";
    $currentChannel = 0;
    for ($i = 0; $i < 1 /*$this->numberOfChannels()*/; $i++) {
      //error_log("GENERATING SCRIPT (Setting): ".$name." -> ".$values[$i]);
      if (!empty ($values[$i])) {
        $result = $result . '$imageName setp -chan ';
        $chan = (int) $currentChannel;
        $result = $result . $chan;
        $result = $result . ' -' . "$command ";
        $result = $result . $values[$i];
        $result = $result . "\n";
        // Update $currentChannel
        $currentChannel++;
      }
    }
    return $result;
  }

  function microscopeParameterString() {
    $sampleSizesString = $this->sampleSizesString();
    $string = '-s {' . $sampleSizesString . '} ';
    return $string;
  }

  function microscopeTypeString() {
    $param = $this->parameter('MicroscopeType');
    $value = $param->translatedValue();
    $result = "-micr $value ";
    return $result;
  }

  // sample size adaption for all microscopes
  function numericalApertureString() {
    //if ($this->isMultiPointOrSinglePointConfocal()) {
    $param = $this->parameter('NumericalAperture');
    $value = $param->translatedValue();
    //} else {
    //    $value = $this->adaptedNumericalApertureFor(1);
    //}
    $result = "-na $value ";
    return $result;
  }

  function pinholeRadiusString() {
    $result = $this->multiChannelParameterString('PinholeSize', 'pr');
    return $result;
  }

  // Support for Nipkow spinning disk
  function pinholeSpacingString() {
    $param = $this->parameter('PinholeSpacing');
    $value = $param->translatedValue();
    $result = "-ps $value ";
    return $result;
  }

  function sampleSizesString() {
    $result = '';
    $result = $result . (string) $this->sampleSizeX() . ' ';
    $result = $result . (string) $this->sampleSizeY();
    if ($this->isThreeDimensional()) {
      $result = $result . ' ' . (string) $this->sampleSizeZ();
    } else {
      // Use current channel
      //$result = $result . ' ' . (string) ($this->idealSampleSizeZFor(1));
    }
    if ($this->isTimeSeries()) {
      $result = $result . ' ' . (string) $this->sampleSizeT();
    }
    return $result;
  }

  function originalSampleSizesString() {
    $result = '';
    $result = $result . (string) ($this->sampleSizeX() / $this->sampleSizeAdaptionFactor()) . ' ';
    $result = $result . (string) ($this->sampleSizeY() / $this->sampleSizeAdaptionFactor());
    if ($this->isThreeDimensional()) {
      $result = $result . ' ' . (string) ($this->sampleSizeZ() / $this->sampleSizeAdaptionFactor());
    } else {
      // Use current channel
      $result = $result . ' ' . (string) ($this->idealSampleSizeZFor(1));
    }
    if ($this->isTimeSeries()) {
      $result = $result . ' ' . (string) $this->sampleSizeT();
    }
    return $result;
  }

  function lensRefractiveIndexString() {
    $param = $this->parameter('ObjectiveType');
    $value = $param->translatedValue();
    $result = "-ril $value ";
    return $result;
  }

  function mediumRefractiveIndexString() {
    $param = $this->parameter('SampleMedium');
    $value = $param->translatedValue();
    $result = "-ri $value ";
    return $result;
  }

  function photonCountString() {
    $result = "-pcnt ";
    if ($this->isTwoPhoton()) {
      $result = $result . "2";
    } else {
      $result = $result . "1";
    }
    return $result;
  }
}

//!---------------------------------------------------------
// \class    JobTaskSetting
// \brief     A job task setting is a complete set of
//           image processing parameters that is used when
//           a job is processed by the queue manager.
//!---------------------------------------------------------
class JobTaskSetting extends TaskSetting {
  //!---------------------------------------------------------
  // @function    JobTaskSetting::table()
  // \brief        Answer the name of the database table in
  //              which the job task settings are stored. The
  //              table contains the setting's name the owner
  //              and the standard (default) flag.
  // \return      String
  //!---------------------------------------------------------
  function table() {
    return "job_task_setting";
  }

  //!---------------------------------------------------------
  // @function    JobTaskParameterSetting::parameterTable()
  // \brief        Answer the name of the database table in
  //              which the parameters for settings of the
  //              receiver's kind are stored.
  // \return      String
  //!---------------------------------------------------------
  function parameterTable() {
    return "job_task_parameter";
  }

  function putScriptOn($script, $corrParams) {
    $step = 1;
    $newScript = $script;

    // Depending on the PSF selection and the settings for the spherical
    // aberration corrections, we have to call the psfComputationString( )
    // function below specifying either a constant or an adaptive PSF.
    // A constant PSF is used when there is a need for correction (i.e.
    // the PSF is theoretical with refractive index mismatch) but (i) the
    // user chose not to let Huygens correct for aberrations; or (ii) when
    // the user performs an advanced correction with static FSF generated
    // at a given depth (this is combined with next check).
    $constant = 0;
    if ( ( $corrParams[ 'AberrationCorrectionNecessary' ] == 1 ) &&
    ( $corrParams[ 'PerformAberrationCorrection' ] == 0 ) ) {
      $constant = 1;
    }

    // If the user chose the advanced correction mode 'partial correction
    // at user defined PSF depth', we also need to pass the depth to the
    // psfComputationString( ) function.
    $depth = 0;
    if ( ( $corrParams[ 'AberrationCorrectionNecessary' ] == 1 ) &&
    ( $corrParams[ 'PerformAberrationCorrection' ] == 1 ) &&
    ( $corrParams[ 'AberrationCorrectionMode' ] == 'advanced' ) &&
    ( $corrParams[ 'AdvancedCorrectionOptions' ] == 'user' ) ) {
      $depth = $corrParams[ 'PSFGenerationDepth' ];
      $constant = 1; // See comment above
    }

    // The various options result in a different value for the -brMode
    // deconvolution flag. This value is to be passed to the
    // fullRestorationString( ) function below.
    if ( $corrParams[ 'AberrationCorrectionNecessary' ] == 0 ) {
      $brMode = 'auto';
    } else {
      if ( $corrParams[ 'PerformAberrationCorrection' ] == 0 ) {
        $brMode = 'one';
      } else {
        if ( $corrParams[ 'AberrationCorrectionMode' ] == 'automatic' ) {
          $brMode = 'auto';
        } else {
          if ( $corrParams[ 'AdvancedCorrectionOptions' ] == 'user' ) {
            $brMode = 'one';
          }
          if ( $corrParams[ 'AdvancedCorrectionOptions' ] == 'slice' ) {
            $brMode = 'sliceBySlice';
          }
          if ( $corrParams[ 'AdvancedCorrectionOptions' ] == 'few' ) {
            $brMode = 'few';
          }
        }
      }
    }

    // effective deconvolution script; step = 3 -> $source = b; $dest = c;
    //$parameter = $this->parameter('FullRestoration');
    //if ($parameter->isTrue()) {
    $source = $this->sourceForStep($step);
    $dest = $this->destinationForStep($step);
    $newScript = $newScript . $this->psfComputationString($source, $constant, $depth);
    $newScript = $newScript . $this->fullRestorationString($source, $dest, $brMode);
    $newScript = $newScript . $this->destroyImageString($source);
    $step++;
    //}
    return $newScript;
  }

  // manage measured PSF
  function putScriptForMeasuredPointSpreadFunctionOn($script) {
    $step = 1;
    $newScript = $script;

    //    $parameter = $this->parameter('FullRestoration');
    //    if ($parameter->isTrue()) {
    $source = $this->sourceForStep($step);
    $dest = $this->destinationForStep($step);
    $newScript = $newScript . $this->fullRestorationForMeasuredPointSpreadFunctionString($source, $dest);
    $newScript = $newScript . $this->destroyImageString($source);
    $step++;
    //    }
    return $newScript;
  }

  function destroyImageString($imageName) {
    $result = '';
    $result = $result . $imageName . ' del';
    $result = $result . "\n";
    return $result;
  }

  function getNumberOfOperations() {
    return 1;

    /*    $result = 0;
     $parameter = $this->parameter('RemoveNoise');
     if ($parameter->isTrue()) {
     $result++;
     }
     $parameter = $this->parameter('RemoveBackground');
     if ($parameter->isTrue()) {
     $result++;
     }
     $parameter = $this->parameter('FullRestoration');
     if ($parameter->isTrue()) {
     $result++;
     }
     return $result;
     */
  }

  function sourceForStep($stepNumber) {
    $stepSources = array (
			'$imageName',
			'a',
			'b'
			);
			$index = $stepNumber -1;
			return $stepSources[$index];
  }

  function destinationForStep($stepNumber) {
    $maxSteps = $this->getNumberOfOperations();
    $stepDestinations = array (
    array (
				'c',
				'a',
				'a'
				),
				array (
				'x',
				'c',
				'b'
				),
				array (
				'x',
				'x',
				'c'
				)
				);
				$index = $stepNumber -1;
				$row = $stepDestinations[$index];
				$index = $maxSteps -1;
				return $row[$index];
  }

  function psfComputationString($source, $constant = 0, $position = 0) {
    // To calculate a theoretical PSF, the best thing is to provide an empty
    // one. Huygens will take the necessary decisions, see
    // http://support.svi.nl/wiki/TheoreticalPsf
    if (!$constant ) {
      return "catch { psf clear }\n";
    }
    // Alternatively, this calculates a constant PSF for the provided
    // parameters, and will be adapted to the sample depth if spherical
    // aberration is present.
    return 'catch { ' . $source . ' genpsf -> psf -dims auto -zPos '.
    $position .' }' . "\n";
  }

  // manage measured PSF
  // never called: to remove
  function removeBackgroundForMeasuredPointSpreadFunctionString($source, $dest) {
    $result = '';
    $result = $result . $source . ' cmle $psf -> ' . $dest . ' ';
    $result = $result . "-it 3 ";		// !!
    $result = $result . '-bgMode object ';
    $result = $result . $this->removeBackgroundPercentString();
    $result = $result . '-blMode auto ';
    $result = $result . '-q 0 ';
    //$result = $result . '-mode fast ';
    $result = $result . '-pad auto';
    $result = $result . "\n";
    return $result;
  }

  function fullRestorationString($source, $dest, $brMode) {
    $result = '';

    $parameter = $this->parameter('DeconvolutionAlgorithm');
    $string = $parameter->name();
    $value = $parameter->value();

    // (Obsolete) This restores the default behavior in case the entry "DeconvolutionAlgorithm"
    // is not in the database
    if ( empty( $value ) == true )
    $value = "cmle";

    $result = $result . $source . ' ' . $value . ' psf -> ' . $dest . ' ';
    //$result = $result . $source . ' cmle psf -> ' . $dest . ' ';
    $result = $result . $this->signalNoiseRatioString();
    $result = $result . $this->maxIterationsString();
    // background estimation manual/auto
    $parameter = $this->parameter("BackgroundOffsetPercent");
    #printDebug("fullRestorationString", $parameter);
    #printDebug(debug_backtrace()); exit;
    $value = $parameter->value();
    $internalValue = $parameter->internalValue();
    //$result = $result . '-bgMode object ';
    //error_log("GENERATING SCRIPT (Setting): background offset percent -> ".$value[0].", ".$value[1]." | ".$internalValue[0].", ".$internalValue[1]." |");
    if ($value[0] == "auto" || $internalValue[0] == "auto") {
      $result = $result . '-bgMode auto ';
    } else if ($value[0] == "object" || $internalValue[0] == "object") {
      $result = $result . '-bgMode object ';
    } else {
      $result = $result . '-bgMode manual ';
      $result = $result . $this->backgroundPerChannelString();
    }
    $result = $result . '-blMode auto ';
    $result = $result . '-q ';
    $parameter = $this->parameter("QualityChangeStoppingCriterion");
    $result = $result . $parameter->value() . " ";
    $result = $result . '-brMode ' . $brMode . " ";
    $result = $result . '-pad auto';
    $result = $result . "\n";
    return $result;
  }

  // manage measured PSF
  function fullRestorationForMeasuredPointSpreadFunctionString($source, $dest) {
    $result = '';

    // (Obsolete) This restores the default behavior in case the entry "DeconvolutionAlgorithm"
    // is not in the database
    $value = $this->decAlgorithmString();
    if ( empty( $value ) == true )
    $value = "cmle";
    $result = $result . $source . ' ' .$value . ' psf -> ' . $dest . ' ';

    //$result = $result . $source . $this->decAlgorithmString() . ' psf -> ' . $dest . ' ';
    //$result = $result . $source . ' cmle $psf -> ' . $dest . ' ';
    $result = $result . $this->signalNoiseRatioString();
    $result = $result . $this->maxIterationsString();
    // background estimation manual/auto
    $parameter = $this->parameter("BackgroundOffsetPercent");
    $value = $parameter->value();
    $internalValue = $parameter->internalValue();
    //$result = $result . '-bgMode object ';
    if ($value[0] == "auto" || $internalValue[0] == "auto") {
      $result = $result . '-bgMode auto ';
    } else if ($value[0] == "object" || $internalValue[0] == "object") {
      $result = $result . '-bgMode object ';
    } else {
      $result = $result . '-bgMode manual ';
      $result = $result . $this->backgroundPerChannelString();
    }
    $result = $result . '-blMode auto ';
    $result = $result . '-q ';
    $parameter = $this->parameter("QualityChangeStoppingCriterion");
    $result = $result . $parameter->value() . " ";
    $result = $result . '-brMode auto ';
    $result = $result . '-pad auto';
    $result = $result . "\n";
    return $result;
  }

  function noiseLevelString() {
    $parameter = $this->parameter('RemoveNoiseEffectiveness');
    $value = $parameter->value();
    $result = '{';
    $result = $result . "$value $value 0 0 }";
    return $result;
  }

  function backgroundPerChannelString() {
    $parameter = $this->parameter('BackgroundOffsetPercent');
    $values = $parameter->value();
    /*if (!is_array($values)) {
     $channels = $this->numberOfChannels();
     $values = array_fill(1, $channels, $values);
     }
     $result = '-bg {';
     for ($i = 0; $i < $this->numberOfChannels(); $i++) {
     $newValue = -1 * (100 - $values[$i]);
     $result = $result . $newValue;
     if ($i < $this->numberOfChannels()) {
     $result = $result . " ";
     }
     }
     $result = $result . '} ';*/

    /* TODO: why does this return channel zero's? */
    $result = '-bg ' . $values[0] . " ";
    return $result;
  }

  function removeBackgroundPercentString() {
    $parameter = $this->parameter('RemoveBackgroundPercent');
    $values = $parameter->value();
    if (!is_array($values)) {
      $channels = $this->numberOfChannels();
      $values = array_fill(1, $channels, $values);
    }
    $result = '-bg {';
    for ($i = 0; $i < $this->numberOfChannels(); $i++) {
      $newValue = -1 * (100 - $values[$i]);
      $result = $result . $newValue;
      if ($i < $this->numberOfChannels()) {
        $result = $result . " ";
      }
    }
    $result = $result . '} ';
    return $result;
  }

  function signalNoiseRatioString() {
    $parameter = $this->parameter('SignalNoiseRatio');
    $values = $parameter->value();
    //if (!is_array($values)) {
    //	$values = array_fill(1, $this->numberOfChannels(), $values);
    //}
    //$result = '-sn {';
    //for ($i = 1; $i <= $this->numberOfChannels(); $i++) {
    //	$result = $result . $values[$i];
    //	if ($i < $this->numberOfChannels()) {
    //		$result = $result . " ";
    //	}
    //}
    //$result = $result . '} ';

    $parameter = $this->parameter('DeconvolutionAlgorithm');
    $deconvolutionAlgorithm = $parameter->value();

    $value = $values[0];
    if ($deconvolutionAlgorithm == "qmle") {
      if ($value == "1")	$value = "low";
      else if ($value == "2")	$value = "fair";
      else if ($value == "3")	$value = "good";
      else if ($value == "4")	$value = "inf";
      else			$value = "fair";
    }

    $result = '-sn ' . $value . " ";
    return $result;
}

function maxIterationsString() {
  $parameter = $this->parameter('NumberOfIterations');
  $value = $parameter->value();
  $result = "-it $value ";
  return $result;
}

function decAlgorithmString() {
  $parameter = $this->parameter('DeconvolutionAlgorithm');
  $value = $parameter->value();
  $result = " $value";
  return $result;
}

}
