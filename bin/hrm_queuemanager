#!/bin/bash
#
# hrm_queuemanager     Huygens Remote Manager - Queue Manager wrapper script

### TASKS / PURPOSE of this wrapper script

# [x] do NOT depend on the names of related processes, use PID's instead!
# [x] allow for setting a custom config file via an environment variable
# [x] do sanity checks regarding the hrm config (are logs writable etc.)
# [ ] take over the start/stop responsibilites for the actual (PHP) daemon
#     [ ] START:
#         [ ] check if another instance of the QM is already running (return)
#         [x] detach (continue in background)
#         [x] update log files
#         [x] start the Queue Manager
#         [x] check success and write PID into file
#         [x] stop QM if pidfile writing failed
#     [x] STOP:
#         [x] kill the actual PHP QM
#         [x] clean up the pid file

# - this script is meant to be run as either the user that should run the QM or as root, in the latter
#   case it will switch to the QM-user by re-exec'ing itself


######################  function definitions  ######################

test_writable() {
    # test if a file or directory is writable, exit otherwise
    if ! [ -w "$1" ] ; then
        echo "ERROR: file or directory not writable: '$1'!"
        exit 1
    fi
}

test_writable_create() {
    # test if a file exists and is writable, try to create it otherwise, if
    # both fails exit with an error message
    if ! [ -e "$1" ] ; then
        touch "$1" 2>/dev/null || {
            echo "ERROR: cannot create file: '$1'!"
            exit 1
        }
    else
        test_writable "$1"
    fi
}

warn_daemon_user() {
    cat << EOF
WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING

Your setup does not have the "SUSER" variable configured to be used for running
the HRM Queue Manager. Usually, this results in the daemon being run as root.

This configuration has been DEPRECATED as of HRM 3.1.0 and is not supported in
HRM 3.2.0 and newer releases. Please see the documentation how to correctly
configure your HRM:

http://huygens-rm.org/

WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING

EOF
}

run_qm_daemon() {
    ### # check if a PID file is existing and whether it contains useful information:
    ### if [ -f "$PID_FILE" ] ; then
    ###     PID=$(more "$PID_FILE")
    ###     if [ -z "$PID" ] ; then
    ###         echo "WARNING: empty PID file found, trying to remove it:"
    ###         $CMD rm -f -v "$PID_FILE"
    ###         exit 1
    ###     else
    ###         echo
    ###         echo "The Queue Manager seems to be running already."
    ###         echo "NOT starting a second instance!"
    ###         usage_exit
    ###     fi
    ### fi

    # TODO: do we really need two different logfiles here?
    echo "Reporting stdout to '$LOG_OUT' and stderr to '$LOG_ERR'."
    MARK="$(date "+%F %H:%M:%S") - starting the HRM Queue Manager"
    MARK="============================= $MARK ============================="
    echo "$MARK" >> "$LOG_OUT"
    echo "$MARK" >> "$LOG_ERR"

    # the PHP QM expects to be run from within the "run/" subdirectory:
    cd "$HRM_HOME/run"
    QUEUEMGR="$PHP_CLI -q $HRM_HOME/run/runHuygensRemoteManager.php"
    $QUEUEMGR 1>> "$LOG_OUT" 2>> "$LOG_ERR" &
    # NOTE: we cannot check the status of the previous command via "$?" as this
    # variable is only set for commands executed in *foreground* (see "man
    # bash" in the "Special Parameters" section), therefore we have to use the
    # method from below.

    # bash provides the PID of the background process in "$!", so remember it:
    QUEUEMGR_PID=$!

    # NOTE: we do *NOT* put the PID of the actual queue manager into the
    # pidfile but the PID of *this* bash process as *we* are meant to stay
    # alive during its runtime to handle signals and clean up after the QM has
    # stopped (upon request/signal or crashed):
    echo $$ > "$PID_FILE" || {
        echo "ERROR: can't write PID file '$PID_FILE'!"
        cleanup_exit
    }

    # loop until we receive SIGINT/SIGTERM or the subprocess exited for some
    # other reason (e.g. because it crashed or was killed directly):
    while :
    do
        sleep 1
        # "jobs -p" lists the PID's of *all* active jobs (asynchronous
        # subprocesses of this bash instance), so the if-clause below would
        # also be true if there was *more* than one subprocess:
        if [ "$QUEUEMGR_PID" != "$(jobs -p)" ] ; then
            echo "WARNING: the HRM Queue Manager is not running any more!"
            # show everything of the errorlog since our startup-mark (maximum
            # of 100 lines) to give a hint what could have gone wrong:
            echo "Showing errorlog entries since startup:"
            echo "------------------ $LOG_ERR ------------------"
            tail -n 100 "$LOG_ERR" | sed "1,/$MARK/d"
            echo "------------------ $LOG_ERR ------------------"
            cleanup_exit 1
        fi
        # NOTE: due to some weird bash behaviour (bug?), the joblist doesn't
        # get updated when "jobs -p" is called but *ONLY* if we call "jobs -l"
        # or something, so we do this explicitly:
        jobs -l > /dev/null
    done
}

cleanup_exit() {
    echo "HRM Queue Manager: cleaning up..."
    # kill the running Queue Manager and clean up the PID file
    kill -15 $QUEUEMGR_PID 2>/dev/null
    rm -f "$PID_FILE"
    # exit with status "0" unless $1 is set explicitly:
    exit ${1-0}
}

usage_exit() {
    echo "Usage: $0 {start|stop|restart}"
    exit 1
}

######################  function definitions  ######################


# Make sure to have a known locale environment for the script:
export LC_ALL=C

# Set the default for the PHP CLI binary (can be overridden in hrm.conf):
PHP_CLI="php"

# hrm.conf defines variable HRM_HOME
set -e
if [ -n "$HRM_CONF" ] ; then
    . "$HRM_CONF"
else
    . /etc/hrm.conf
fi
set +e

if [ -n "$DEBUG_HRMD" ] ; then
    set -o xtrace
fi

# Global variables definition:
LOG_OUT="${HRM_LOG}/log.txt"
LOG_ERR="${HRM_LOG}/error_log.txt"
PID_FILE="${HRM_LOG}/hrmd.pid"

# HRM_LOG needs to be writable as we store the pidfile there at the moment:
test_writable "${HRM_LOG}"
test_writable_create "${LOG_OUT}"
test_writable_create "${LOG_ERR}"

# install the signal handler:
trap "cleanup_exit" SIGINT SIGTERM

# refuse to start if no SUSER is configured:
if [ -z "$SUSER" ] ; then
    warn_daemon_user
    exit 1
fi

# re-exec with correct user in case we were started as root:
if [ "$(id -u)" = 0 ] ; then
    exec su -l $SUSER -c "$0 $@"
fi

# refuse to start if we were started with the wrong account:
WHOAMI=$(id -u -n)
if [ "$WHOAMI" != "$SUSER" ] ; then
    echo "User mismatch: '$WHOAMI' <-> '$SUSER'."
    exit 2
fi

# detach into background if requested
if [ "$1" = "--detach" ] ; then
    shift
    echo "Forking background process..."
    "$0" "$@" &
    exit 0
fi

# once we reach this point we have made sure to run as the appropriate user and
# backgrounding has happened (if requested), so we can then start the actual
# daemon function:
run_qm_daemon
